{"componentChunkName":"component---src-components-templates-blog-post-js","path":"/posts/Vue常见面试题/","result":{"data":{"markdownRemark":{"fields":{"slug":"posts/Vue常见面试题/"},"frontmatter":{"title":"Vue常见面试题","description":"vue2自带的生命周期有哪些？发送请求在created还是mounted中呢？","date":"2023 年 03 月 20 日","thumbnail":"assets/img/1_YMQc5b6UaCNIOl6RvIfYwA.jpeg"},"html":"<h2>生命周期方面</h2>\n<h3>1.1 vue2自带的生命周期有哪些？发送请求在created还是mounted中呢？</h3>\n<p>vue2自带的生命周期有哪些？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">beforeCreate  //创建前  无DOM 无data\ncreated  // 创建后  无DOM 有data，methods被挂载\nbeforeMount  // 挂载前  无DOM 有data\nmounted  // 挂载后 有DOM 有data\nbeforUpdata  // 数据更新前\nupdatad  // 数据更新后\nbeforDestroy  // 组件销毁前\ndestroyed  // 组件销毁后\n\n### 进入组件后会默认执行前四各生命周期，beforeCreate -&gt; mounted</code></pre></div>\n<p>发送请求在created还是mounted中呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">根据项目来进行选择，但是在mounted发起请求，如果组件包含子组件，那么会先执行完子组件前四个钩子函数，再执行父组件上的mounted方法。如果业务是父组件引入子组件，并且优先加载子组件的数据，那么父组件的请求可以放在mounted里面，如果子组件需要父组件的请求数据，那么需要将父组件请求放在created里面，如果当前组件没有依赖关系，放哪儿都行。</code></pre></div>\n<h3>1.2 为什么发送请求不在beforCreate里？beforeCreate和created有什么区别？</h3>\n<p>为什么发送请求不在beforCreate里？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">因为：在beforCreate中调用methods会报找不到的错误，在此周期里无法拿到函数</code></pre></div>\n<p>beforeCreate和created有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">beforeCreate中没有$el和$data，拿不到methods里的方法\n在created中没有$el，但有$data，拿得到methods里的方法</code></pre></div>\n<h3>1.3 父组件引入子组件，生命周期的执行顺序是？</h3>\n<p> 先将父组件的前三个beforeCreate 、created、 beforeMount执行，拿到deta数据(因为子组件可能需要使用到父组件的是数据)，然后执行子组件的前四个beforeCreate 、created、 beforeMount、mounted后，再执行父元素上的mounted函数。</p>\n<h3>1.4 在created中怎么获取DOM节点？</h3>\n<p>只要是异步操作都可以或获取DOM节点，例如：异步请求后.then去拿，async await，setTimeout(()=>{})，this.$nextTick(res=>{}),因此也证明了$netTick是异步的。</p>\n<p>Vue怎么获取DOM？可以利用原生js获取，Vue也提供了this.$refs.child获取DOM。</p>\n<p>setTimeout和this.$nextTick一起使用，先执行this.$nextTick</p>\n<h3>1.5加入keep-alive会执行哪些生命周期？</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">activated // 组件激活\ndeactivated // 组件失活</code></pre></div>\n<h3>1.6第二次或第N次进去，组件 会执行哪些生命周期？</h3>\n<p>当组件加入了keep-alive，只会执行一个生命周期,组件激活，因为keep-alive会将组件缓存，不会销毁</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">进入会激活组件 所以只执行activated\n切换会失活组件，会执行deactivaed</code></pre></div>\n<h3>1.7你在什么情况使用哪些生命周期，说一说生命周期的使用场景</h3>\n<div class=\"gatsby-highlight\" data-language=\"tetx\"><pre class=\"language-tetx\"><code class=\"language-tetx\">created   --&gt;  单组件请求\nmounted   --&gt;  同步可以获取DOM，先子组件请求后父组件请求\nactivated --&gt;  进入一个详情页面，判断id是否跟上一次进入的id相等，如果不相等发起请求\ndestroyed --&gt;  关闭页面记录视频播放时间，初始化的时候从上一次的历史播放记录开始播放</code></pre></div>\n<p><strong>如果watch 加了 immediate: true, 就是watch先执行，否则就是created 先执行，如果有computed ，vue默认先computed 再执行watch</strong></p>\n<h2>组件方面</h2>\n<h3>2.1vue组件通信的方式（就是传值）？</h3>\n<p>--- 父传子（子组件拿到父组件的数据）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 父组件用:strl='strl'，子组件用props：['strl']进行接收,子组件template里面可以直接使用\n2. 子代也可以直接使用this.$parent(父母亲).str1 拿取，也能在template里面使用  --子组件可以直接修改$parent.str1的值--</code></pre></div>\n<p>--- 后代如果需要使用父(祖)组件：  --->就是依赖注入provide(提供)/inject(注入)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">父组件\n    provide(){\n        return {\n         val1:'这是val1'\n        }\n    }\n后代组件\n\t在template里面可以直接使用{{val1}}\n\t在js里面用inject['val1']z注入后，就可以使用了\n1. 优势：父组件可以直接向某个后代组件直接传值，不用一级一级传递，</code></pre></div>\n<p>--- 子传父：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 在子组件定义自定义事件this.$emit('chenge',this.val1)向父组件传递</code></pre></div>\n<p>--- 兄弟之间传值</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">1. 在src下建utils工具文件夹下建立bus.js,使用bus中间媒介进行中转\nbus.js 里面写法：\n\timport Vue  from &#39;vue&#39;\n\texport default new Vue()\n组件A里：\n\timport bus from &#39;bus,js&#39;\n\tbus.$emit(&#39;changs&#39;,&#39;strA&#39;)\n组件B里：\n\timport bus from &#39;bus,js&#39;\n\tcreated(){\n        bus.$on(&#39;changs&#39;,val=&gt;{\n        console.log(val)  // val=&#39;starA&#39;\n    })\n    }</code></pre></div>\n<p>!!!--- 组件间通信方式、父组件如何直接修改子组件的值、子组件如何直接修改父组件的值  这三个是常问的面试题</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">父组件如何直接修改子组件的值:\n1.  &lt;子组件 ref='child'>&lt;子组件/>\n\t父组件上使用this.$refs.child.xxx = 'yyy'\n子组件如何直接修改父组件的值:\n1. 子组件可以使用：this.$parent.xxx去修改</code></pre></div>\n<h3>2.2如何找到父组件</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.$parent</code></pre></div>\n<h3>2.3如何找到根组件</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.$root 就会找到id='app' 的跟组件</code></pre></div>\n<h3>2.4slot/插槽</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">匿名插槽 &lt;slot>这是内容&lt;/slot></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">具名插槽 \n父：\n&lt;template #title>\n\t这是标题内容\n&lt;/template>\n子：\n&lt;slot name=\"title\" /></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">作用域插槽 传值\n子：\n&lt;slot name=\"title\"  :arr='data'/>\n父：\n&lt;template #title=\"{arr}\">\n\t这是标题内容,arr是传过来的值\n&lt;/template></code></pre></div>\n<h3>2.5 如何封装组件</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">组件封装要将一定难度的，涉及的知识点：slot、组件通信，下来将表单二次封装看熟</code></pre></div>\n<h2>vuex方面</h2>\n<h3>3.1vuex结构</h3>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">state：{\n\tname:&#39;xiaoming&#39; // 定义全局使用的数据\n},\ngetters:{ \n},\nmutations:{\n},\nactions:{\n},\nmodules:{\n}</code></pre></div>\n<h3>3.2Vuex的mutations和actions的区别</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">都是来存放全局方法的，这个方法return的值拿不到\n区别：\nmutations：只能执行同步操作。是来修改state的值的。\nactions：返回的是一个Promise对象，它可以执行相关异步操作。是来提交mutations的</code></pre></div>\n<h2>路由方面</h2>\n<h3>4.1路由的模式</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">hash、history\n区别：\n1.找不到当前页面发送请求的问题\nistory会给后端发送一个请求，hash不会，他不会，解决方法就是可以设置一个404页面\n2.关于项目打包前端自测问题\nhash是可以看到内容的，history是默认不能看到，只有通过一定配置才可以\n3.表象不同\nhash：#     history： /</code></pre></div>\n<h3>4.2$router和$route区别</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$router包含当前路由和整个路由的属性方法\n$route包含当前路由对象</code></pre></div>\n<h3>4.3导航守卫</h3>\n<ul>\n<li>全局导航守卫</li>\n<li>路由独享守卫</li>\n<li>组件内守卫</li>\n</ul>\n<h3>4.4路由传参的方式</h3>\n<h6>1、router-link路由导航</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h6>2、调用$router.push实现路由传参</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h6>3、 通过路由属性中的name匹配路由，再根据params传递参数</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h6>4、 通过query来传递参数</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h6>总结：query传参通过path跳转，params传参通过name跳转</h6>\n<h2>API方面</h2>\n<h3>5.1  $set</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">面试官：你有没有用到过数据更新，视图没有更新的问题\n\tthis.$set(target,key(index),修改后的值)</code></pre></div>\n<h3>5.2  $nextTick</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$nextTick返回的参数[函数]，是Promise异步回调。功能：获取更新后的dom元素</code></pre></div>\n<h3>5.3  $refs</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">获取dom元素的</code></pre></div>\n<h3>5.4  $el</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">获取当前组件的根节点</code></pre></div>\n<h3>5.5  $data</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">获取当前组件的data数据的</code></pre></div>\n<h3>5.6  $children</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">获取到当前组件的所有子组件，返回数组格式</code></pre></div>\n<h3>5.7  $parent</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">找到当前组件的父组件，如果找不到，则返回自身</code></pre></div>\n<h3>5.8  $root</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">就会找到id='app' 的跟组件</code></pre></div>\n<h3>5.9  data定义数据</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">数据定义在return内和外的区别\n\tretuen外 --> 单纯修改数据是不可以修改的，因为没有被get/set\n\tretuen内 --> 是可以修改的</code></pre></div>\n<h3>5.10 computed计算属性</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">computed属性值可以被修改吗？\n\t是可以被修改的，  需要通过get/set写法\n\n当前组件v-model绑定的值是computed来的，可以被修改吗？\n\t也是可以的，需要被get/set</code></pre></div>\n<h3>5.11  watch监听属性</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">监听对象属性变化需要开启深度监听 deep：true\n初始化监听需要开启 immediate：ture\n\nwatch也能监听路由路径变化</code></pre></div>","timeToRead":7}},"pageContext":{"slug":"posts/Vue常见面试题/","previousPost":{"fields":{"slug":"posts/阶段一面试题/"},"frontmatter":{"title":"阶段一面试题"}},"nextPost":null}},"staticQueryHashes":["3344698684","3792814546"]}