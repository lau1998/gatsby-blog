{"componentChunkName":"component---src-components-templates-blog-post-js","path":"/posts/面试题（重点）(li)/","result":{"data":{"markdownRemark":{"fields":{"slug":"posts/面试题（重点）(li)/"},"frontmatter":{"title":"面试题（重点）(li)","description":"面试题（重点）(li)!","date":"2021 年 02 月 03 日","thumbnail":"assets/img/Captura de Tela 2021-02-03 às 19.12.24.png"},"html":"<h5>1、盒子模型？弹性盒子的理解？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">盒子模型：\n（1）两种，IE 盒子模型、标准 W3C 盒子模型；IE 的 content 部分包含了 border 和pading<span class=\"token punctuation\">;</span>\n（2）盒模型：内容<span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span>、填充<span class=\"token punctuation\">(</span>padding<span class=\"token punctuation\">)</span>、边界<span class=\"token punctuation\">(</span>margin<span class=\"token punctuation\">)</span>、 边框<span class=\"token punctuation\">(</span>border<span class=\"token punctuation\">)</span>.\n\n弹性盒子：\n弹性盒模型<span class=\"token punctuation\">(</span>flexbox<span class=\"token punctuation\">)</span>又称为弹性布局，是css3中新提出的一种布局方式，引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</code></pre></div>\n<h5>2、CSS3动画样式transition、transform、animation之间的区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">transform：1. transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\n          2. transform属性是静态属性，需要配合transition和animation才能展现出动画效果。你可以把它看成是跟left、top等属性一样，只是一个静态样式而已。\n\nanimation：一个css3的动画属性，需要配合@keyframes 使用\n\n区别： 1. transition是css中检测指定属性变化进行自动补间动画的属性。\n      2. animate是先指定好动画过程中的关键帧属性，进行动画的属性。\n\n<span class=\"token property\">transition</span><span class=\"token punctuation\">:</span>过渡动画，常用参数：过渡一个属性all<span class=\"token punctuation\">,</span>延迟时间，动画时间，执行动画效果linear\ntransform：位移动画，scale、translate、skew、rotate\nanimation：执行动画，需要和@keyframe配合使用</code></pre></div>\n<h5>3、样式居中有哪些方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">给父元素相对定位\n给子元素绝对定位，并且：\nleft: 50%;top: 50%;\nmargin-left: 负的宽度一半。\nmargin-top: 负的高度一半；\n\n\n使用display:flex；\njustify-content：center；\nalign-items：center；\n\n\n使用定位的方式\n父元素设置为：position: relative;\n子元素： position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        margin: auto;\n        \n        \n定位translate\n父元素设置为：position: relative;\n子元素： position: absolute;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);        </code></pre></div>\n<h5>4、对定位(position)的理解，默认值、absolute、fixed、relative的区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">relative：相对定位，根据right；top；left；bottom等属性，相对自己原来的位置偏移，原位置还会占位置。添加给父元素做辅助作用\n\nabsolute：绝对定位，不占位置 父元素有定位属性根据父元素位置来定位自己的位置，父元素没有根据html定位\n\nfixed（老 IE 不支持）：固定定位，不占位置，根据浏览器的窗口<span class=\"token punctuation\">(</span>html<span class=\"token punctuation\">)</span>来定义自己的位置</code></pre></div>\n<h5>5、CSS选择器优先级？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token important\">!important</span> > id > class > 标签\n<span class=\"token important\">!important</span> 比 内联优先级高\n\n优先级就近原则，样式定义最近者为准<span class=\"token punctuation\">;</span>\n以最后载入的样式为准<span class=\"token punctuation\">;</span></code></pre></div>\n<h5>6、rem、em、px之间的区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">px（像素）：页面默认的尺寸计算单位，绝对长度<span class=\"token punctuation\">,</span>它是相对于显示器屏幕分辨率而言的\n    特点：1. IE无法调整那些使用px作为单位的字体大小\n         2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；\n         3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器<span class=\"token punctuation\">(</span>或内核<span class=\"token punctuation\">)</span>。\n\nem：相对长度，相对于应用在当前元素的字体尺寸；一般浏览器默认字体大小为16px，则 1em = 16px\n    特点：1. em的值并不是固定的；\n         2. em会继承父级元素的字体大小。\n\nrem（root em）：相对单位，相对于html根元素字体大小的单位，当html的font-size：16px时，1rem = 16px\n    特点：1. 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。\n\t\t2. 除了IE8及更早版本外，所有浏览器均已支持rem。\n\n\n为什么给font-size设置为62.5%： 方便换算！\n    1. 因为绝大多数浏览器的默认字体大小为 16px ，而将font-size设置为 62.5% <span class=\"token property\">则等价于字体大小的font-size</span><span class=\"token punctuation\">:</span>10px<span class=\"token punctuation\">;</span>\n    2. 随之在其他的换算单位，如 rem 的字体换算时，则可以表示为 1rem = 10px， 整数值对于单位的换算会比较方便\n    3. 但是在Chrome（谷歌浏览器）中，支持最小字体的大小为 12px ，解决办法就是 将html根字体设置为 <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> 625%<span class=\"token punctuation\">;</span> 意：1rem = 100px ，以此单位换算</code></pre></div>\n<h5>7、输入URL地址到页面渲染出来都处理了哪些事情？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、浏览器输入 url。先解析 url 地址是否合法\n2 浏览器检查是否有缓存（浏览器缓存 - 系统缓存 - 路由器缓存）。如果有，直接显示。如果没有，跳到第三步。\n3. DNS解析 解析获取对应过的 ip 地址\n4. TCP连接<span class=\"token punctuation\">(</span>三次握手<span class=\"token punctuation\">)</span>\n5. 客户端向服务端发送http请求  请求数据包\n6. 服务器处理请求，返回http报文\n7、浏览器解析响应。如果响应可以缓存，则存入缓存\n8.浏览器发送请求获取嵌入在 HTML 中的资源（html，css，JavaScript，图片，音乐等），对于未知类型，会弹出对话框\n9、浏览器发送异步请求\n10. 页面全部渲染结束</code></pre></div>\n<p><img src=\"C:%5CUsers%5C86150%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220607085629973.png\" alt=\"image-20220607085629973\"></p>\n<h5>8、浏览器渲染的基本原理？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">浏览器将获取的html文档解析成dom树\n处理css标记，构成层叠样式表模型CSSOM  （css、object  model）\n将DOM和CSSom合并为渲染树  （将要被渲染的对象）\n渲染树的玫瑰元素包含的内容都是计算过的，浏览器使用一种流失处理的方法，只需要一此pass会在操作就可以布局所有的元素\n将渲染树的节点渲染到页面上 这一步</code></pre></div>\n<h5>9、let、const、var定义变量有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、var定义的变量，没有块的概念，可以跨块访问<span class=\"token punctuation\">,</span> 不能跨函数访问。有变量提升\n2、let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。没有变量提升\n3、const用来定义常量，使用时必须初始化<span class=\"token punctuation\">(</span>即必须赋值<span class=\"token punctuation\">)</span>，只能在块作用域里访问，而且不能修改。没有变量提升</code></pre></div>\n<h5>10、call、apply、bind有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">call方法<span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>是<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>的一颗语法糖，作用和<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>一样，同样可实现继承，唯一的区别就在于<span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>接收的是参数列表，而<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>则接收参数数组。\n\nbind方法<span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>的作用与<span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>和<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>一样，都是可以改变函数运行时上下文，区别是<span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>和<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>在调用函数之后会立即执行，而<span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用 不会立即执行       call 传对象。 apply 传数组    </code></pre></div>\n<h5>11、JS的基础数据类型有哪些？null和undefined有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">string  Number  Boolean   null   undefined    es6新增的   symbol    Bigint\n\nnull     定义了类型但是赋的值为空  \n\nundefined ：1、  函数没有返回值，默认返回undefined、\n\n​\t   2、调用函数时，应该提供参数没有提供，那么这个参数就等于undefined\n\n​\t   3、当前对象没有赋值的属性，那么此属性的值就为undefined</code></pre></div>\n<h5>12、JS的原型链是什么？怎么使用它来实现继承？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">原型链：每一个构造函数都有一个原型对象，每一个原型对象都包含一个构造函数，每个实例都包含一个原型对象\nprototype （普若图泰普）\n继承：对象实例通过原型链的方式串联起来，当访问目标的某一属性时，就能通过原型链查找。达到继承的效果 （原型链继承关键步骤在与：将子类原型和父类原型关联起来，使原型链能够连接上，将子类原型指向父类来实现关联）</code></pre></div>\n<h5>13、JS继承有哪些方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1.原型链继承 \n2.借用构造函数继承   call/apply  把this重新指向\n3.组合继承<span class=\"token punctuation\">(</span>原型+借用构造<span class=\"token punctuation\">)</span> \n4.原型式继承 \n5.寄生式继承 \n6.寄生组合式继承</code></pre></div>\n<h5>14、页面的重排、重绘有什么区别？回流机制是什么？</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">重排： 如果我们的盒子发生了变化（宽度、高度、内边距、外边距、字体等发生了变化，那么需要重新布局，就会引起重排）。重排一定会引起重绘\n重绘：完成重排后，浏览器会重新绘制把受影响的部分到浏览器上，这个过程就成为重绘，重排必然会引发重绘。 页面重绘不一定会重排   \n\n回流就是重排</code></pre></div>\n<h5>15、样式的link和@import引入有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">link属于html 标签，而@import是CSS中提供的 在页面加载的时候，link会同时被加载，而@import引用的CSS会在页面加载完成后才会加载引用的CSS\n \n@import只有在ie5以上才可以被识别，而link是html标签，不存在浏览器兼容性问题\n   link引入样式的权重大于@import的引用（@import 是将引用的样式导入到当前的页面 中）\n    \nlink支持使用Javascript控制DOM去改变样式；而@import不支持\nlink可以引入任何资源 @import只能在css文件中引入css文件\nlink是同步的 。@import是异步的。    </code></pre></div>\n<h5>16、如何理解Promise、Promise.all、Promise.race这之间的区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、promise 可以避免出现回调地狱 后期维护方便\n\n2、promise.all 属于同步执行，数据全部返回后才会显示  \n    all。如果有一个错误返回会怎么样。 如果有任何一个错误，那么只会在catch里面获取到这个错误请求\n\n3、promise.race 属于异步操作，不管成功还是失败，那个执行完成就先返回那个值\n\t\t\trace赛跑机制，只接受第一个返回的结果</code></pre></div>\n<h5>17、如何理解闭包？它有什么优缺点？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">含义：外部函数  内部定义一个内部函数，内部函数使用的外部函数的局部变量，外部函数返回了内部函数\n主要是避免数据全局污染，所以对数据盒操作数据的方法进行封装\n优点：\n\t希望一个变量长期存储在内存中。\n\t避免数据全局变量的污染。\n\t私有成员的存在。\n缺点：\n\t常驻内存，增加内存使用量。\n\t使用不当会很容易造成内存泄露。\n\t过度使用闭包会引起内存泄露</code></pre></div>\n<h5>18、JS对象的深浅拷贝都是什么？有哪些实现方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token property\">深拷贝</span><span class=\"token punctuation\">:</span>拷贝的是对象或者数组内部数据的实体，重新开辟了内存空间存储数据；\n<span class=\"token property\">浅拷贝</span><span class=\"token punctuation\">:</span>拷贝的是引用类型的指针，副本和原数组或对象指向同一个内存；\n\n浅拷贝：....展开运算符、for循环做拷贝，jQuery.data方法也可以进行拷贝<span class=\"token punctuation\">,</span>ladash.clone\n\t\n深拷贝：for递归循环、JSON.parse（JSON.<span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>）函数和undefined会丢失<span class=\"token punctuation\">,</span>lodash.clonedeep</code></pre></div>\n<h5>19、数组去重有哪些方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token number\">1</span>、Set  <span class=\"token operator\">+</span>基础数据类型  不能对对象去重   为<span class=\"token constant\">ES6</span>新增的一个对象，允许存储任何类型（原始值或引用值）的唯一值\n<span class=\"token number\">2</span>、使用双重<span class=\"token keyword\">for</span>循环，再利用数组的splice方法去重\n<span class=\"token number\">3</span>、利用数组的indexOf 需要加<span class=\"token keyword\">for</span> 方法去重   \n   <span class=\"token comment\">//注：array.indexOf(item,statt) 返回数组中某个指定的元素的位置，没有则返回-1</span>\n<span class=\"token number\">4</span>、利用数组的sort方法去重（相邻元素对比法\n   <span class=\"token comment\">//array.sort( function ) 参数必须是函数，可选，默认升序</span>\n<span class=\"token number\">5</span>、利用对象的属性不能相同的特点去重\n   <span class=\"token comment\">//用数组项作为对象的属性会自动去除相同的值</span>\n<span class=\"token number\">6</span>、利用数组的includes去重\n   <span class=\"token comment\">//arr.includes(指定元素(必填),指定索引值(可选,默认值为0) )，有值返回true，没有则返回false</span>\n<span class=\"token number\">7</span>、利用数组的filter方法去重\n  <span class=\"token comment\">//filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，</span>\n<span class=\"token number\">8</span>、利用函数递归去重\n<span class=\"token number\">9</span>、利用<span class=\"token constant\">ES6</span>中的Map方法去重</code></pre></div>\n<h5>20、判断数据都有哪些方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、typeof 太破欧服\n\t返回基础数据类型\n2、instanceof   因丝腾此 欧服\n\n\t用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true，否则返回false。instanceof检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。\n3、constructor  肯丝爪可它\n\n\t当一个函数F被定义时，JS引擎会为F添加prototype（坡的太铺）原型，然后在prototype上添加一个constructor属性，并让其指向F的引用，F利用原型对象的constructor属性引用了自身，当F作为构造函数创建对象时，原型上的constructor属性被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。\n\t这样做的意义是，让对象诞生以后，就具有可追溯的数据类型。\n\t\t\t\t\t\t\t\t\t\t\t\t\n4、Object.prototype.<span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>.<span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>是Object的原型方法，调用该方法，默认返回当前对象的类型，格式是[object<span class=\"token punctuation\">,</span>xxx]<span class=\"token punctuation\">,</span>对于Object对象，直接调用<span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>就能返回[object Object]<span class=\"token punctuation\">,</span>而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。\t</code></pre></div>\n<h5>21、堆栈的区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，\n堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，\n堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化\n\n栈：是内存中存储值类型的，大小为2M，超出则会报错，内存溢出</code></pre></div>\n<h5>22、for...in 和 Object.keys 有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">Object.keys \n只能遍历自身的属性  不会遍历原型链上的属性   \n1.遍历结果为对象自身属性组成的数组，数组中的属性名排列顺序与使用for in循环遍历该对象时返回的顺序一致，\n2.与for in区别在于不能遍历出原型链上的属性；\n\nfor...in \n遍历所有属性\n1.作用于数组的for in除了会遍历数组元素外<span class=\"token punctuation\">,</span>还会遍历自定义的属性<span class=\"token punctuation\">,</span>以及原型链上的属性<span class=\"token punctuation\">;</span>\n2.作用于数组的for in的遍历结果是数组的索引<span class=\"token punctuation\">,</span>且都为字符串型<span class=\"token punctuation\">,</span>不能用于运算<span class=\"token punctuation\">;</span>\n3.某些情况下<span class=\"token punctuation\">,</span>可能按照随机顺序遍历数组元素<span class=\"token punctuation\">;</span></code></pre></div>\n<h5>23、变量提升如何理解？var 和 function提升有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">在变量的作用域内，不管变量在何处声明，都会被提升到作用域的顶部，但是变量初始化的顺序不变.\n\n使用var定义变量，声明的变量会提升到作用域顶部，但是赋值操作并不会提升；使用function声明函数，整个声明语句都会得到提升。所以声明提升提升的是对函数或变量的声明，而不是赋值！</code></pre></div>\n<h5>24、事件捕获和冒泡？事件委托是什么原理？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。\n事件冒泡：当事件发生后，这个事件就要开始传播（从里向外或者从外向里）。\n事件委托原理：事件委托是利用了冒泡，通过委托可以减少事件绑定的次数，提高程序的性能。</code></pre></div>\n<h5>25、new 关键字都执行了哪些业务？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1.创建一个新对象\n2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n3.执行构造函数中的代码（为这个新对象添加属性）\n4.返回新对象</code></pre></div>\n<h5>26、JS中有哪些操作会引起内存泄露？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">意外的全局变量引起的内存泄露\n2、闭包引起的内存泄漏\n3、没有清理的 DOM 元素引用   比如button<span class=\"token punctuation\">,</span>image<span class=\"token punctuation\">,</span>text\nfunction <span class=\"token function\">removeButton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n4、被遗忘的定时器或者回调\n5、子元素存在引起的内存泄露</code></pre></div>\n<h5>27、document.onload 和 onready有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1.onready或者$<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>比onload先执行\n\n2.onready或者$<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>是页面解析完成之后执行，而onload是在页面所有元素加载完成后执行\n\n3.onload只执行最后一个 而onready或者$<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>可以执行多个</code></pre></div>\n<h5>28、跨域是如何产生的，都有哪些解决跨域的方法？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">跨域出现的原因：浏览器的同源策略，同源策略主要用来防止CSRF攻击，同源策略会阻止一个域的JavaScript脚本和另外一个域的内容进行交互\n出现跨域的场景：域名、端口号、协议有任何一个不一样的时候，就会出现跨域\n\n解决方法：\n1、通过jsonp跨域\n2、postMessage跨域\n3、跨域资源共享（CORS）\n4、nginx代理跨域\n5、nodejs中间件代理跨域\n6、WebSocket协议跨域</code></pre></div>\n<h5>29、原生ajax如何实现的？http状态码：200、302、304、400、403、404、500、503分别是什么意思呀？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">200 OK //客户端请求成功 \n400 Bad Request //客户端请求有语法错误，不能被服务器所理解 \n403 Forbidden //服务器收到请求，但是拒绝提供服务 \n404 Not Found //请求资源不存在，输入了错误的 URL \n500 Internal Server Error //服务器发生不可预期的错误 \n503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</code></pre></div>\n<h5>30、cookie、localStorage、sessionStorage有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">cookie可以设置日期，日期到了后自动删除。  \nlocalStorage 本地储存。不手动删除一直保存\nsessionStorage 会话存储空间   网页关闭后自动删除</code></pre></div>\n<h5>31、如何实现防抖和节流？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">防抖：\n用户多次触发事件，在用户一直触发事件中，事件不会执行，只有在用户停止触发事件一段时间之后再执行这个事件一次。\n\n（原理）用户每一次触发事件都会延迟执行，在设置延迟定时器执之前都会把上一次延迟定时器清除，最终只有用户连续触发这个事件的间隔时间超出我们设置的参数ms毫秒之后<span class=\"token punctuation\">,</span>该事件才会触发一次\n\n节流：\n用户多次触发事件，在用户一直触发事件过程中事件会每间隔一段时间执行一次，会执行多次。\n\n（原理）用户每一次触发事件都会设置一个延迟定时器，但是如果已经设置了延迟定时器就会等上一次延迟定时器执行之后才会开启下一个定时器，这样用户一直触发事件，事件会每间隔一段时间执行一次</code></pre></div>\n<h5>32、常见的字符串方法有哪些？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、字符串的比较 equals（）方法而不是使用==关系运算符，因为==比较的是字符串的内存地址；参数为字符串数组或者字符串都可以，返回值类型为Boolean值。\n\n2、字符串的搜索 indexOf（）\n\n3、截取子字符串 substring （）方法方法从字符串中截取需要的区间字符串，参数为整数，返回值为字符串。\n\n4、去除首尾空白字符：使用trim方法可以移除字符串首尾的空白字符，参数为字符串，返回值类型也为字符串，并且还有isEmpty <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>判断字符串是否为空字符串，与参数，返回值为Boolean值。\n\n5、替换字符串：使用replace（）方法，参数为字符或者字符串，返回值为字符串。\n\n6、分割字符串：使用split <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法，参数为字符串，返回值为字符串数组。\n\n7、拼接字符串：使用静态方法join（）方法，可以把指定的字符串连接成字符串数组，参数为字符串数组，返回值为字符串。\n\n8、格式化字符串：使用format （）静态方法，可以传入其他占位符，然后生成新的字符串。返回值为字符串。\n\n9、类型转换：可以把任意基本类型或者引用类型转换成字符串，使用的是静态方法value（）并且这是一个重载方法。参数可以为整数，小数，字符，字符串，或者Boolean值，返回值为Boolean值，int<span class=\"token punctuation\">,</span>double<span class=\"token punctuation\">,</span>字符串，\n\n10、转换为char[]字符数组：String 和char[]类型可以相互转换。参数为字符串或者字符，返回值为字符或者字符串。\n\n11、字符编码：ASCII码，GB2312，Unicode，或者UFT-8。英文的占用一个字节，中文的占用两个字节。\n\n12、延伸阅读：早期版本的JDK     String 总是以char[]存储。</code></pre></div>\n<h5>33、常见的数组方法有哪些？splice和slice有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">增  <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度\n\t<span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>在数组开头添加任意多个值，然后返回新的数组长度\n     <span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组\n\t<span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组\n删 \n\t<span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项\n\t<span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项\n\t<span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组\n改\n\t<span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响\n\n查\n\t<span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>返回要查找的元素在数组中的位置，如果没找到则返回 -1\n\t<span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>返回要查找的元素在数组中的位置，找到返回true，否则false\n\t<span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>返回第一个匹配的元素\n\n\n排序方法 <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法接受一个比较函数，用于判断哪个值应该排在前面\n\t\t<span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串\n迭代方法 / 批处理方法  \n\t<span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true\n\t<span class=\"token function\">every</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true\n\t<span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>对数组每一项都运行传入的函数，没有返回值\n\t<span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回\n\t<span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组\n\nsplice截取一段数组不会影响原数组  ，slice截取一段数组 影响原数组</code></pre></div>\n<h5>34、箭头函数和普通函数有哪些区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、箭头函数没有自己的this指向，它的this指向来源于它的上级，并且继承而来的this指向是无法改变的。\n2、箭头函数由于没有自己的this，所以不能作为构造函数。   没有返回值\n3、箭头函数中没有arguments（形参数组）</code></pre></div>\n<h5>35、模块化有哪些方式？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">AMD  依赖前置：提前引入，文件开头吧需要的模块一次性全部引入，后面直接使用，前期消耗比较大，后期执行效率很高代表作是require.js\nCMD 按需加载：在代码执行过程当中需要一模块了才去加载，代表作是sea.js  现在不怎么使用了\nES6 Module  各大主流浏览器都支持  另外 服务器端Node.js 准训common.js规范 module.exports导出模块 require引入模块。\n\nrequire.js</code></pre></div>\n<h5>36、[\"1\", \"2\", \"3\"].map(parseInt) 答案是多少？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1、NaN  NaN</code></pre></div>\n<h5>37、如何优化网页加载速度？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1.减少 css，js 文件数量及大小<span class=\"token punctuation\">(</span>减少重复性代码，代码重复利用<span class=\"token punctuation\">)</span>，压缩 CSS 和 JS 代码 \n2.图片的大小 \n3.把 css 样式表放置顶部，把 js 放置页面底部 \n4.减少 http 请求数 \n5.使用外部 JS 和 CSS\n合并http请求、精灵图（雪碧图）、字体（矢量图）、减少CDN</code></pre></div>\n<h5>38、如何实现对象的合并？数组的合并？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">对象的合并\n方式一：扩展运算符 ...\n扩展运算符合并对象当键名（属性名）相同时后面替换前面的\n方式二：Object.<span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>目标对象，来源对象<span class=\"token punctuation\">)</span> 合并对象\n来源对象往目标对象合并，返回目标对象\n如果目标对象、来源对象第一级属性名相同（键名）时，来源对象中的属性会替换目标对象中的属性，可以理解成后面替换前面属性中相同的键\n方式三：for...in\n简单数据类型合并  引用数据类型合并\n数组的合并\nconcat，合并两个或多个数组 <span class=\"token punctuation\">(</span>会造成内存浪费，不能处理嵌套数组<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>...<span class=\"token punctuation\">)</span>展开运算符</code></pre></div>\n<h5>39、map和forEach有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">1. 两者都可以用来遍历数组，forEach无返回值，map会映射并返回一个新的数组。\n2. forEach会允许修改原数组的值，而map不能修改原数组的值。</code></pre></div>\n<h5>40、for...in 和 for...of 有什么区别？</h5>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">for...in只能获得对象的属性名，对数组来说是下标。并且手动添加的属性也能遍历到。\nfor...of可以用于遍历字符串也可以遍历数组 只能取得键值（数组），遍历对象会报错。</code></pre></div>\n<p><strong>Vue面试题</strong></p>\n<p><strong>01、虚拟dom是什么？</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">1、虚拟 DOM 就是用来模拟 DOM 的一个对象，这个对象拥有一些重要属性，并且更新 UI 主要就是通过 DIFF 方法对比旧的虚拟 DOM 树 和新的虚拟 DOM 树的区别完成的。\n\n虚拟 DOM 的优点:\n减少 DOM 操作\n减少频率 (将多次操作合并为一次, 如添加 1000 个节点却一个接一个操作)\n减少范围 (将多余的操作省掉, 如添加 1000 个节点其中只有 10 个是新增的)\n跨平台\n虚拟 DOM 不仅可以变成 DOM, 还可以变成小程序, ios 应用等, 本质是一个 js 对象\n虚拟 DOM 的缺点\n需要额外的创建函数, 如 createElement 或者 h, 但可以用 JSX 来简化成 XML 写法</code></pre></div>\n<p>02、双向绑定原理是什么？v-model组件实现的原理是什么？Object.defineProperty和Proxy有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">通过Object.defineProperty方法来给数据属性绑定setter和getter方法，进行数据赋值和获取值的一个劫持；vue核心库通过观察和消息发布来实现数据更新提示去更新内容、数据。\n分别利用了v-bind用来绑定value的值，用v-on去绑定input标准事件，这是事件用来监听当输入域内容发生变化的时候来执行一些事情。\n“Object.defineProperty无法一次性监听所有属性,要通过Object.keys进行循环遍历,Proxy不需要,直接可以监听所有属性。”</code></pre></div>\n<p>03、v-if 和 v-show 有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">(1)、v-if和v-show用于视图层进行条件判断视图展示\n\n(2)、v-if的原理是根据判断条件来动态的进行增删DOM元素，v-show是根据判断条件来动态的进行显示和隐藏元素，频繁的进行增删DOM操作会影响页面加载速度和性能，由此我们可以得出结论：\n\n当您的项目程序不是很大的时候，v-if和v-show都可以用来进行判断展示和隐藏（这种场景使用v-if只是影响不大，并不是没有影响）；\n\n当您的项目程序比较大的时候，不推荐使用v-if来进行判断展示和隐藏，推荐使用v-show；\n\n (3)、只有v-if能和v-else连用进行分支判断，v-show是不能和v-else连用的，如果出现多种条件场景的情况下，可以使用v-if来进行判断</code></pre></div>\n<p>04、data为什么不是对象而是一个函数？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">“因为在组件复用的时候会重新生成一个对象,而data是一个对象的话(因为对象是引用数据类型),data数据会被复用;而当data是一个函数的时候每次调用的时候就会返回一个新的data对象。”</code></pre></div>\n<p>05、watch和computed属性有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">1、功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。\n2、是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。\n3、是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。\n4、computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）\n5、使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.</code></pre></div>\n<p>06、v-for中key的作用？diff算法？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">1.在写 v-for 的时候,都需要给元素加上一个 key 属性\n2.key 的主要作用就是用来提高渲染性能的!\n3.key 属性可以避免数据混乱的情况出现(如果元素中包含了有临时数据的元素,如果不用 key 就会产生数据混乱)\n\n“diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较,并替换为新的节点,具体过程就是调用Patch方法,比较新旧节点,一边比较一边给真实DOM打补丁进行替换”</code></pre></div>\n<p>07、extends和mixins有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">1.mixins接收对象数组(可理解为多继承),extends接收的是对象或函数(可理解为单继承)\n2.优先级&gt;extends&gt;mixins,继承钩子函数的时候,是不进行覆盖的,extends的钩子函数先触发,而后再是mixins的钩子函数触发,最后就是组件自身的钩子函数触发。\n3.mixins类似于面向切面的编程(AOP),extends类似于面向对象的编程</code></pre></div>\n<p>08、对vue中插槽的理解？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">插槽就是子组件中的提供给父组件使用的一个占位符，用&lt;slot&gt;&lt;/slot&gt; 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的&lt;slot&gt;&lt;/slot&gt;标签。\n\n插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制简单来说就是组件外部维护参数及结构,内部安排位置</code></pre></div>\n<p>09、$nextTick的理解？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">“nextTick(),是将回调函数延迟在下一次dom更新数据后调用,简单的理解是:当数据更新了,在dom中渲染后,自动执行该函数”</code></pre></div>\n<p>10、父子组件传值都有哪些方法？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">父传子：通过父组件绑定自定义属性（或通过 v-bind 绑定动态属性），子组件使用 props 选项时显式的声明 props，以便它可以从父组件接收到期望的数据。\n子传父：通过父组件绑定自定义事件，子组件通过 this.emit(&#39;自定义事件&#39;,value) 传值。\n非父子：可以使用一个空的 Vue 实例绑定在 Vue 实例的原型上作为一个事件总线中心 (vue.prototype.eventBus = new Vue())，用 emit 触发事件，on 监听事件。</code></pre></div>\n<p>11、生命周期的理解？常用vue生命周期有哪些？created和mounted有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">8个，创建，挂载，更新，销毁 \ncreated、mounted和beforeDestoryed \ncreated 数据和虚拟dom都完成创建，并且完成关联关系，不能获取虚拟dom，但是可以使用异步获取虚拟dom，如果非异步赋值，一定不会二次渲染\nmounted 完成虚拟dom挂载，并不能保证样式渲染完成，如果赋值，一定会二次渲染</code></pre></div>\n<p>12、update生命周期出发是否有条件？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">只有data里的变量改变并且要在页面重新渲染完成之后,才会进updated生命周期，只改变data里的值但是没有再页面上渲染该值的话并不会触发updated方法。</code></pre></div>\n<p>13、事件总线如何实现的？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">全局事件总线就是为了实现各个组件的自由通信，传递数据\n\n原理是假设有组件A和组件B，A和B之间关系可以是兄弟，父子，爷孙任意关系。然后A和B之间有一个中间商C，然后A可以在自身给C设置一个自定义事件，以及回调函数，然后假如B要给A传数据，就可以通过这个自定义事件去启动它，再后面传入数据作为参数。因此事件触发后运行回调函数，因为回调函数在A自身上，所所以A就得到了数据。</code></pre></div>\n<p>14、如何实现样式作用域？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vue中要给样式添加作用域,只需要给style标签添加scoped属性即可.</code></pre></div>\n<p>15、vue-router有哪几种路由模式？实现的原理是什么？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">“vue-router有3种路由模式:hash,history,adstract.默认是hash\nhash原理：在 url 中的 # 之后对应的是 hash 值, 其原理是通过hashChange() 事件监听hash值的变化, 根据路由表对应的hash值来判断加载对应的路由加载对应的组件\nhistory原理：history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求(将url替换并且不刷新页面)</code></pre></div>\n<p>16、如何实现路由组件懒加载？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1、vue异步组件技术 ==== 异步加载\n2、组件懒加载方案二 路由懒加载(使用import)\n3、 组件懒加载方案三: webpack提供的require.ensure() </code></pre></div>\n<p>17、路由导航卫士(钩子函数)有哪些？常用的钩子函数是哪些？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">全局前置守卫 beforeEach\n全局解析守卫 beforeResolve \n全局后置钩子 afterEach \n\n创建前/后： 在beforeCreated阶段，vue实例的挂载元素el还没有。在created阶段,vue实例的数据对象data有了,el还没有.\n\n载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，\n\ndata.message还未替换。在mounted阶段，vue实例挂载完，data.message成功渲染。\n更新前/后：当data变化时，会触发beforeUpdate和updated方法。\n\n销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</code></pre></div>\n<p>18、路由传参有哪些方式？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1.params 传参（显示参数）又可分为 声明式 和 编程式 两种方式\n声明式router-link：该方式是通过router-link组件的to属性实现，子路由需要提前配置好参数\n编程式 this.$router.push：同样需要子路由提前配置好参数。\n2、params传参（不显示参数）也可分为声明式和编程式两种方式，与显示参数不同的是，这里是通过路由的别名 name 进行传值的\n3、.query 传参（显示参数）也可分为声明式和编程式 两种方式\n声明式router-link：该方式是通过 router-link 组件的 to 属性实现，不过使用该方式传值的时候，需要子路由提前配置好路由别名\n编程式 this.$router.push：使用该方式传值的时候，同样需要子路由提前配置好路由别名（name 属性）</code></pre></div>\n<p>19、keep-alive组件的理解？它的生命周期有哪些？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1、keep-alive是Vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁。\n2、生命周期函数：在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子activated 与 deactivated。\nactivated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。\ndeactivated钩子：组件被停用（离开路由）时调用。</code></pre></div>\n<p>20、vuex是什么？为什么要使用vuex？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1、vuex是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化\n2、使用 vue/react 等框架，需要关注点基本就是数据，因为框架解决了数据和页面更新的实现\n所以组件和数据之间的对应关系，随着项目的复杂，变得混乱。所以需要统一管理数据，把数据的存取集中到一个地方，所有的组件都从这个地方取数据，更新数据也集中到同一个地方。</code></pre></div>\n<p>21、vuex有哪些常用属性？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vuex的属性有：1、state，用来存储变量；2、mutations，提交更新数据的方法；3、actions，用来解决异步流程来改变state数据；4、getters，对state里面的变量进行过滤的；5、modules。</code></pre></div>\n<p>22、vuex中为什么不能在mutations中进行异步赋值？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Mutation必须是同步函数\nvuex和redux都是一种状态管理机制。然后他们会有自己的state（状态）和修改state的方法，修改state的方法涉及到同步和异步，vuex的处理方式是同步在mutation里面，异步在actions里面，然后redux的同步就是reducer,异步更多的是用户自己去通过中间件的方式去实现</code></pre></div>\n<p>23、如何实现数据持久化(刷新页面不丢失)？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">将vuex中的数据进行本地存储，防止页面刷新丢失vuex中的数据。</code></pre></div>\n<p>24、axios有什么优点？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 支持Promise API\n\n2. 拦截请求和响应\n\n3. 转换请求数据和响应数据\n\n4. 取消请求\n\n5.自动转换json数据</code></pre></div>\n<p>25、ref是什么？如何实现实例传参或方法调用？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ref是组件的特殊属性，组件被渲染后，指向组件的一个引用。可以通过组件的ref属性，来获取真实的组件。 因为，组件并不是真正的DOM节点，而是存在于内存中的一种数据结构，称为虚拟的DOM，只有当它真正的插入文档之后，才变为真正的DOM节点\n\nref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期 mounted(){} 钩子中调用，或者在 this.$nextTick(()=>{}) 中调用。</code></pre></div>\n<p>26、修饰符</p>\n<p>.stop 阻止事件冒泡</p>\n<p>.prevent 阻止默认事件</p>\n<p>.self 避免事件冒泡 (只有自身才能触发)</p>\n<p>.once 只能触发一次</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;!-- 阻止事件冒泡 --&gt;\n    &lt;p @click=&quot;paerts()&quot;&gt;\n      父元素\n      &lt;span @click.stop=&quot;sons()&quot;&gt;子元素&lt;/span&gt;\n    &lt;/p&gt;\n    &lt;!-- 阻止默认事件 --&gt;\n    &lt;a @click.prevent=&quot;sons()&quot; href=&quot;baidu.com&quot;&gt;链接&lt;/a&gt;\n\n    &lt;!-- 避免事件冒泡 (只有自身才能触发)--&gt;\n    &lt;p @click.self=&quot;paerts()&quot;&gt;\n      父元素\n      &lt;span @click=&quot;sons()&quot;&gt;子元素&lt;/span&gt;\n    &lt;/p&gt;\n\n    &lt;!-- 只能触发一次 --&gt;\n    &lt;button @click.once=&quot;paerts()&quot;&gt;一次&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {};\n  },\n  computed: {},\n  methods: {\n    paerts() {\n      console.log(&quot;父元素方法&quot;);\n    },\n    sons() {\n      console.log(&quot;子元素方法&quot;);\n    }\n  }\n};\n&lt;/script&gt;</code></pre></div>","timeToRead":27}},"pageContext":{"slug":"posts/面试题（重点）(li)/","previousPost":{"fields":{"slug":"posts/面试重点/"},"frontmatter":{"title":"js相关面试题"}},"nextPost":{"fields":{"slug":"posts/阶段三VUE面试题/"},"frontmatter":{"title":"第三阶段Vue面试题"}}}},"staticQueryHashes":["3344698684","3792814546"]}