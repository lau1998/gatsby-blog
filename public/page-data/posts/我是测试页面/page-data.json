{"componentChunkName":"component---src-components-templates-blog-post-js","path":"/posts/我是测试页面/","result":{"data":{"markdownRemark":{"fields":{"slug":"posts/我是测试页面/"},"frontmatter":{"title":"生命周期方面","description":"vue2自带的生命周期有哪些？发送请求在created还是mounted中呢？","date":"2023 年 03 月 20 日","thumbnail":"assets/img/1_YMQc5b6UaCNIOl6RvIfYwA.jpeg"},"html":"<h2>生命周期方面</h2>\n<h3>1.1 vue2自带的生命周期有哪些？发送请求在created还是mounted中呢？</h3>\n<p>vue2自带的生命周期有哪些？</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">beforeCreate  //创建前  无DOM 无data\ncreated  // 创建后  无DOM 有data\nbeforeMount  // 挂载前  无DOM 有data\nmounted  // 挂载后 有DOM 有data\nbeforUpdata  // 数据更新前\nupdatad  // 数据更新后\nbeforDestroy  // 组件销毁前\ndestroyed  // 组件销毁后\n\n### 进入组件后会默认执行前四各生命周期，beforeCreate -&gt; mounted</code></pre></div>\n<p>发送请求在created还是mounted中呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">根据项目来进行选择，但是在mounted发起请求，如果组件包含子组件，那么会先执行完子组件前四个钩子函数，再执行父组件上的mounted方法。如果业务是父组件引入子组件，并且优先加载子组件的数据，那么父组件的请求可以放在mounted里面，如果子组件需要父组件的请求数据，那么需要将父组件请求放在created里面，如果当前组件没有依赖关系，放哪儿都行。</code></pre></div>\n<h3>1.2 为什么发送请求不在beforCreate里？beforeCreate和created有什么区别？</h3>\n<p>为什么发送请求不在beforCreate里？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">因为：在beforCreate中调用methods会报找不到的错误，在此周期里无法拿到函数</code></pre></div>\n<p>beforeCreate和created有什么区别？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">beforeCreate中没有$el和$data，拿不到methods里的方法\n在created中没有$el，但有$data，拿得到methods里的方法</code></pre></div>\n<h3>1.3 父组件引入子组件，生命周期的执行顺序是？</h3>\n<p> 先将父组件的前三个beforeCreate 、created、 beforeMount执行，拿到deta数据(因为子组件可能需要使用到父组件的是数据)，然后执行子组件的前四个beforeCreate 、created、 beforeMount、mounted后，再执行父元素上的mounted函数。</p>\n<h3>1.4 在created中怎么获取DOM节点？</h3>\n<p>只要是异步操作都可以或获取DOM节点，例如：异步请求后.then去拿，async await，setTimeout(()=>{})，this.$nextTick(res=>{}),因此也证明了$netTick是异步的。</p>\n<p>Vue怎么获取DOM？可以利用原生js获取，Vue也提供了this.$refs.child获取DOM。</p>\n<p>setTimeout和this.$nextTick一起使用，先执行this.$nextTick</p>\n<h3>1.5加入keep-alive会执行哪些生命周期？</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">activated // 组件激活\ndeactivated // 组件失活</code></pre></div>\n<h3>1.6第二次或第N次进去，组件 会执行哪些生命周期？</h3>\n<p>当组件加入了keep-alive，只会执行一个生命周期,组件激活，因为keep-alive会将组件缓存，不会销毁</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">进入会激活组件 所以只执行activated\n切换会失活组件，会执行deactivaed</code></pre></div>\n<h3>1.7你在什么情况使用哪些生命周期，说一说生命周期的使用场景</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">created   -->  单组件请求\nmounted   -->  同步可以获取DOM，先子组件请求后父组件请求\nactivated -->  进入一个详情页面，判断id是否跟上一次进入的id相等，如果不相等发起请求\ndestroyed -->  关闭页面记录视频播放时间，初始化的时候从上一次的历史播放记录开始播放</code></pre></div>\n<p><img src=\"assets/img/aae.png\" alt=\"girl\" title=\"girl\"></p>","timeToRead":2}},"pageContext":{"slug":"posts/我是测试页面/","previousPost":{"fields":{"slug":"posts/como-instalar-configurar-e-utilizar-o-firebase-em-aplicações-react-native/"},"frontmatter":{"title":"Como instalar, configurar e utilizar o Firebase em aplicações React Native"}},"nextPost":null}},"staticQueryHashes":["3344698684","3792814546"]}