{"componentChunkName":"component---src-components-templates-blog-post-js","path":"/posts/阶段二面试题/","result":{"data":{"markdownRemark":{"fields":{"slug":"posts/阶段二面试题/"},"frontmatter":{"title":"阶段二面试题。","description":"前端第二阶段面试题。","date":"2021 年 07 月 08 日","thumbnail":"assets/img/como-se-tornar-um-dev-ilda-neta.png"},"html":"<h1>■ 符号说明</h1>\n<p>💘 课题   </p>\n<p>🌟 常见重要   </p>\n<p>🌛 需要有印象的</p>\n<h1>💘 Week1</h1>\n<h2>🌟 说出JS数据类型有哪些</h2>\n<p>原始类型/基本类型：null、undefined、boolean、number、string、symbol、bigint\n对象类型/引用类型/复杂/复合类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">可调用/执行对象「函数」：function\n标准普通对象：object\n标准特殊对象：Array、Date、Math、RegExp、Error……\n非标准特殊对象：Number、String、Boolean……</code></pre></div>\n<h2>🌟 JS引用类型object、array还有哪些</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">可调用/执行对象「函数」：function\n标准特殊对象：Array、Date、Math、RegExp、Error……\n非标准特殊对象：Number、String、Boolean……</code></pre></div>\n<h2>🌟 如何把数据强制转换为数值型</h2>\n<p>说明：面试概率低、工作概率高</p>\n<p>语法：parseInt、parseFloat、Number</p>\n<h2>🌛  说出数据转换为布尔型的结果</h2>\n<p>null、undefined、0、NaN、空字符串结果是false、其他都是true</p>\n<h2>🌛  说出数据转换为字符串型的结果</h2>\n<p>都字符串</p>\n<p>String(内容)、内容.toString()</p>\n<p>​     </p>\n<h2>🌛  说出数据转换为数值型的结果</h2>\n<p>Number（数据）</p>\n<table>\n<thead>\n<tr>\n<th>数据</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>null</td>\n<td>0</td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>true/false</td>\n<td>1/0</td>\n</tr>\n<tr>\n<td>123/NaN</td>\n<td>123/NaN</td>\n</tr>\n<tr>\n<td>''/'123'/'123a'</td>\n<td>0/123/NaN</td>\n</tr>\n</tbody>\n</table>\n<h2>🌛  说出下述隐式转换的结果</h2>\n<p>var result = 100 + true + 21.2 + null + undefined + \"Tencent\" + [] + null + 9 + false;</p>\n<p>[] + [] // \"\"</p>\n<p>[] + {} // \"[object object]\"</p>\n<p>{} + [] // 0 对于编译器而言，代码块不会返回任何的值， 接着+[]就变成了一个强制转number的过程</p>\n<p>true+true+true===3 // true</p>\n<p>true-true // 0</p>\n<p>true==1\t// true</p>\n<p>true===1 // false  </p>\n<p>9+\"1\" // 91</p>\n<p>91-\"1\"\t// 90  </p>\n<p>[]==0 // true    Number([])      0</p>\n<h2>🌛 null 和 undefined 有什么区别？</h2>\n<p>undefined 表示未定义，新定义的变量没有赋值就是undefined</p>\n<p>null表示清空，当一个变量不用的时候，除了等待网页关闭销毁，也可以把它赋值为null。此时浏览器会进行一个回收也就是清空内存。</p>\n<blockquote>\n<p>了解1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">typeof(null)会是一个object。最初这么设计的原因为：通常用作一个空引用一个空对象的预期,就像一个占位符。typeof的这种行为已经被确认为一个错误，虽然提出了修正，出于后兼容的目的，这一点已经保持不变。</code></pre></div>\n<p>了解2</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">null == undefined    true\nnull === undefined   false</code></pre></div>\n</blockquote>\n<h2>🌛 为什么 0.1 + 0.2 !== 0.3? 你如何解决这个问题？</h2>\n<p>因为 <code class=\"language-text\">0.1</code> 这样的数值用二进制表示你就会发现无法整除，</p>\n<p>最后算下来会是<code class=\"language-text\">0.0001100110011001...</code>由于存储空间有限，位数是无限的，只能取近似。</p>\n<p>代码：0.1 + 0.2 == 0.3 // false</p>\n<p>代码：0.625 + 0.625 == 1.25  // true</p>\n<blockquote>\n<p>进制转换规则：<a href=\"https://www.runoob.com/w3cnote/decimal-decimals-are-converted-to-binary-fractions.html\">https://www.runoob.com/w3cnote/decimal-decimals-are-converted-to-binary-fractions.html</a> </p>\n<p>十进制整数 -> 转二进制</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">举例：(5).toString(2) // 结果 101\n转换：除2反向取余\n2| 5    --- 余1\n------\n2| 2    --- 余0\n------\n1    \n\n举例：(13).toString(2) // 结果 1101\n转换：除2反向取余\n2| 13    --- 余1\n------\n2| 6     --- 余0\n------\n2| 3     --- 余1\n------\n1    \n\n核对：https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F732%2Faf802c5be33b4934e6a6fec52a208734.png&amp;refer=http%3A%2F%2Fwww.pianshen.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1642634303&amp;t=293eccde3cc561a3ed2d38f8cf57eea9</code></pre></div>\n<p>十进制小数 -> 转二进制</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">举例：(0.625).toString(2) // 结果 0.101\n转换：乘2正向取整\n0.625*2=1.25======取出整数部分1 \n0.25*2=0.5========取出整数部分0 \n0.5*2=1==========取出整数部分1 \n\n举例：(0.7).toString(2)  // 结果 0.101100110011001100110011 0011 ...\n0.7*2=1.4========取出整数部分1 \n0.4*2=0.8========取出整数部分0 \n0.8*2=1.6========取出整数部分1 \n0.6*2=1.2========取出整数部分1 \n0.2*2=0.4========取出整数部分0　 \n0.4*2=0.8========取出整数部分0 \n0.8*2=1.6========取出整数部分1 \n0.6*2=1.2========取出整数部分1 \n0.2*2=0.4========取出整数部分0\n...</code></pre></div>\n</blockquote>\n<h2>🌟 实战购物车小数计算精度丢失如何解决？</h2>\n<p>推荐解决： 浮点数转化成整数</p>\n<p>实战使用：购物车结算时，商品价格(33.01)-优惠券价格(5)，本应该是28.01，但是实际的结果是28.009999999999998</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">33.01 - 5 = 28.009999999999998\n\n(33.01*100 - 5*100) / 100 = 28.01</code></pre></div>\n<blockquote>\n<h4>es6 解决办法</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">es6 提供了 Number.EPSILON，这个值等于 2^-52 ，这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近 0，但不等于 0，这个时候我们只要判断误差值在这个范围内就可以说明是相等的。\n\nfunction numbersequal(a,b){\n return Math.abs(a-b)&lt;Number.EPSILON\n}\nvar a = 0.1 + 0.2;\nvar b = 0.3;\nconsole.log(numbersequal(a, b))\n// true</code></pre></div>\n<h4>四舍五入</h4>\n<p>采用四舍五入方法，取了一个 10 位小数</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function numTofixed(num) {\n if (typeof num == 'number') {\n     num = parseFloat(num.toFixed(10))\n }\n return num;\n}\n\nnumTofixed(0.1 + 0.2);\n// 0.3</code></pre></div>\n<h4>使用第三方库</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">math.js\nbignumber.js\n....</code></pre></div>\n</blockquote>\n<h1>💘 Week2</h1>\n<h2>- day1</h2>\n<h2>🌟 说出变量在内存中的分配</h2>\n<p>栈：存 原始类型【名字】&#x26;【数据】、对象类型的【名字】&#x26;【堆地址】</p>\n<p>堆：对象类型数据</p>\n<h2>🌟 说出变量赋值内存分配</h2>\n<p>原始类型：变量赋值，栈开辟内存直接存数据   ->  数据互不影响\n对象类型：变量赋值，栈开辟内存，存放堆地址  -> 数据相互影响</p>\n<p>切记切记切记：形参也会出现传值、传地址问题  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var num = 100      \nfunction fn(n) {  \n  // var 形参 = 实参\n  // var n = num也就是100   原始类型 传值 不影响\n  n = 200\t\t \n  console.log(n)   // 打印： 200\n}\nfn(num)             \nconsole.log(num)   // 打印： 100\n\n// --------------------------\n\nvar obj = { name: 'Jack' }    \n\nfunction fn(o) {\t \t  \n  // var 形参 = 实参\n  // var o  = obj    对象类型赋值 传地址  相互影响\n  o.name = 'Rose'\t  \t//    \n  console.log(o.name) //  打印：Rose\n}\nfn(obj)\t\t\t\t  \nconsole.log(obj.name) //  打印：Rose\n\n栈   \t\t   \t\t\t\t\t\t  \t\t\t\t\t\t\t\t  \t 堆\nobj：地址1\t  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  地址1：{ name: 'Jack改成Rose' }  \nfn函数里面的o变量：地址1 函数调用完毕o变量就销毁了 </code></pre></div>\n<h2>- day2</h2>\n<h2>🌟 判断是否是数组</h2>\n<p>方法1：通过语法 Array.isArray() </p>\n<p>方法2：instanceof</p>\n<p>方法3：原型链（constructor）</p>\n<p>.....</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Array.isArray([1, 2 ,3])     \t // true\n[1, 2 ,3] instanceof Array \t   // true\n[1, 2 ,3].constructor === Array // true\n\nArray.isArray('aa')     \t // false\n'aa' instanceof Array \t   // false\n'aa'.constructor === Array // false</code></pre></div>\n<h2>🌛 如何交换两个变量的值</h2>\n<ul>\n<li>临时变量法</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 1\nvar b = 2;\nvar temp = a\na = b\nb = temp</code></pre></div>\n<ul>\n<li>加减法</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 1\nvar b = 2;\na = a+b  // a = 1+2 = 3\nb = a-b  // b = 3-2 = 1\na = a-b  // a = 3-1 = 2</code></pre></div>\n<ul>\n<li>解构赋值法   week3</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 1\nvar b = 2;\n\n[a, b] = [b, a]</code></pre></div>\n<ul>\n<li>数组法</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 1\nvar b = 2\na = [a, b]\nb = a[0]\na = a[1]</code></pre></div>\n<ul>\n<li>对象法</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 1\nvar b = 2\na = { a: b, b: a }\nb = a.b\na = a.a</code></pre></div>\n<ul>\n<li>等等太多了</li>\n</ul>\n<h2>🌟 说出数组有哪些方法</h2>\n<p>·数据操作：shift/unshift/pop/push</p>\n<p>遍历数据：  forEach/map/filter/find/findIndex  </p>\n<p>工作常用：concat/join/indexOf/includes</p>\n<p>学习常用：reverse/splice</p>\n<p>了解：sort </p>\n<h2>🌟 说出数组哪些方法会改变原数据</h2>\n<p>数据操作：shift/unshift/pop/push</p>\n<p>学习常用：reverse/splice</p>\n<p>了解：sort   </p>\n<h2>🌟 如何实现数组去重</h2>\n<p>方法1：通过es6新增的Set数据结构、和展开运算符去重     [...new Set(重复数组)]    week3</p>\n<p>方法2：通过filter配合indexOf实现数组去重</p>\n<p>方法3：定义空数组，通过forEach遍历重复的数组，通过indexOf判断当前值是否在数组中，不在就push</p>\n<p>方法4：定义空数组，通过forEach遍历重复的数组，通过includes判断当前值是否在数组中，不在就push</p>\n<p>方法5：利用对象的属性去重</p>\n<p>方法6：....</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 方法1：通过es6新增的Set数据结构结果     [...new Set(重复数组)]\nvar arr = [1,2,3,2,3]\nconsole.log([...new Set(arr)])\n\n\n// 方法2：通过filter配合indexOf实现数组去重\nvar arr = [1,2,3,2,3]\nvar newarr = arr.filter(function(item, i) {\n    // i=0  item值是1  arr.indexOf(item)  返回0  真\n    // i=1  item值是2  arr.indexOf(item)  返回1  真 \n    // i=2  item值是3  arr.indexOf(item)  返回2  真\n    // i=3  item值是2  arr.indexOf(item)  返回1  假\n    // i=4  item值是3  arr.indexOf(item)  返回2  假\n    return i === arr.indexOf(item);\n}) \nconsole.log(newarr)\n\n\n// 方法3：定义空数组，通过forEach遍历重复的数组，通过indexOf判断当前值是否在数组中，不在就push\nvar newarr = []\nvar arr = [1,2,3,2,3]\narr.forEach(function(item, i) {\n    if (newarr.indexOf(item) === -1)\n    {\n        newarr.push(item)\n    }\n})\nconsole.log(newarr)\n\n\n// 方法4：定义空数组，通过forEach遍历重复的数组，通过includes判断当前值是否在数组中，不在就push\nvar newarr = []\nvar arr = [1,2,3,2,3]\narr.forEach(function(item, i) {\n    if (!newarr.includes(item))\n    {\n        newarr.push(item)\n    }\n})\nconsole.log(newarr)\n\n// 方法5：利用对象的属性去重\nvar arr = [1,2,3,2,3]\nvar newarr = []\nvar obj = {}\narr.forEach(function(item) {\n\tif (!obj[item]) {\n\t\tobj[item] = item // 出现记录\n    newarr.push(item)\n\t}\n})</code></pre></div>\n<h2>- day3</h2>\n<h2>🌟 说出字符串常用方法</h2>\n<p>工作常用：数组、查找、替换、截取、大小、空格</p>\n<blockquote>\n<p>split、replace、substr、toUpperCase/toLowerCase、trim、slice</p>\n</blockquote>\n<p>学习：.length、lastIndexOf、repeat</p>\n<h2>🌛 JS如何去空格</h2>\n<p>说明： 通过 trim 去左右空格</p>\n<p>留心：中间不能去</p>\n<p>追问：JS如何去所有空格</p>\n<p>解决：通过2021年 ES12新增语法replaceAll来解决</p>\n<blockquote>\n<p> ' a b c '.replaceAll(' ', '')</p>\n</blockquote>\n<p>解决：通过正则 </p>\n<blockquote>\n<p> ' a b c '.replace(/\\s/g, '')</p>\n</blockquote>\n<h2>- day4&#x26;5</h2>\n<h2>🌛 伪数组</h2>\n<p>长得像数组，能用少部分的属性 例如length  但是所有方法都不可以使用，在js中常见的伪数组有</p>\n<p>document.qsa、arguments等等</p>\n<h2>🌟 谈谈你对this指向的理解</h2>\n<p>面试： 调用当前方法的对象  也就是谁调用的打印的就是谁</p>\n<p>举例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function fn1() {} \nfn1() // 最大全局变量window调用的\n\n标签对象.事件类型 = 处理函数  // 标签对象触发后调用的</code></pre></div>\n<p>学习 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">普通函数   window\n对象函数   对象本身\n事件函数   事件源\n定时器函数  window\n箭头函数   父function中的this  父没有function就是window\n自定义     call/apply/bind\n构造函数   this === 实例化对象 === 公共空间/原型对象上方法中的this \n\n\n其他：事件、构造函数、公共空间/原型对象上方法-优先使用普通函数写法，当需要明确改变this指向的时候再换箭头函数，\n其他全不优先使用箭头函数。</code></pre></div>\n<h2>🌟 图片懒加载原理</h2>\n<p>好处：减少HTTP请求</p>\n<p>原理：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1、监控滚动条滚动\n2、获取总可视内容高度（可见视口高度+滚动条滚动高度）\n3、获取所有图片\n4、遍历步骤3（或这说：遍历伪数组）\n5、在步骤4中判断，图片.offsetTop &lt;= 步骤2    成立-修改src属性为data-src、失败-不管\n6、节流防抖优化</code></pre></div>\n<p>留心：有时候图片高度获取怎么不到？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!-- 195x265 -->\n&lt;br />\n&lt;img src=\"./imgs/1.jpg\" alt=\"\">\n\n&lt;script>\nvar imgObj = document.querySelector('img')\nconsole.log(imgObj.offsetWidth); // 0  部分属性必须再图片加载完毕后才能获取到其值\nconsole.log(imgObj.offsetLeft);  // 8\n\nimgObj.onload = function() {\n    console.log(imgObj.offsetWidth); // 195\n    console.log(imgObj.offsetLeft);  // 8\n}\n&lt;/script></code></pre></div>\n<h2>🌟 性能优化：网站首屏加载过慢如何解决</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function lazyload() \n{\n    // 1 每次获取最新的 可见视口 + 滚动的高度\n    // 2 获取所有图片\n    // 3 遍历\n    // 4 判断：当前图片的.offsetTop &lt; 步骤1（可见视口 + 滚动的高度）\n    // 不成立-不管\n    // 成立-修改图片的src地址 改成真是的  \n\n\n    // 1 每次获取最新的 可见视口 + 滚动的高度\n    var temp1 = window.innerHeight || document.documentElement.clientHeight  // 兼容ie\n    var temp2 = document.body.scrollTop || document.documentElement.scrollTop // 兼容doctype\n    var maxShowHeight = temp1 + temp2\n    // 2 获取所有图片\n    var imgs = document.querySelectorAll('img')\n    // 3 遍历\n    imgs.forEach(function(item, index) { // item就是每一个图片标签对象\n        // 4 判断：当前图片的.offsetTop &lt; 步骤1（可见视口 + 滚动的高度）\n        // 不成立-不管\n        // 成立-修改图片的src地址 改成真是的  \n        // console.log(item, item.offsetTop , maxShowHeight)\n        if (item.offsetTop &lt; maxShowHeight)\n        {\n            // item.src = item.src-real  切记非标签默认属性 不能直接点\n            item.src = item.getAttribute('src-real')\n        }\n    })\n}\n\n// TODO: 待后续进一步优化\n// 首次\nlazyload() \n// 后续\n// window.onscroll = lazyload()  错误 undefined\nwindow.onscroll = lazyload</code></pre></div>\n<h1>💘 Week3</h1>\n<h2>🌛 谈谈你对事件流机制的理解</h2>\n<p>术语：事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</p>\n<p>学习：多个标签嵌套，事件触发-先检查当前标签，然后继续向上挨个检查祖先标签有没有事件 有就触发的现象就是事件流</p>\n<p>DOM事件流分为三个阶段，分别为：</p>\n<p>捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；</p>\n<p>目标阶段：真正的目标节点正在处理事件的阶段；</p>\n<p>冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段。</p>\n<p><img src=\"https://img2018.cnblogs.com/common/1642186/201911/1642186-20191115181135676-64079695.png\"> </p>\n<h2>🌛 谈谈你对事件委托的理解</h2>\n<p>概念：利用事件冒泡机制处理指定一个事件处理程序，来管理某一类型的所有事件。</p>\n<p>事件委托的好处：</p>\n<ul>\n<li>利用冒泡的原理，将事件加到父级身上，这样只在内存中开辟一块空间，既节省资源又减少DOM操作，提高性能</li>\n<li>可以为动态添加的元素绑定事件</li>\n</ul>\n<h2>🌛 正则</h2>\n<p>匹配手机号：/^1\\d{10}$/.test(数据)</p>\n<p>匹配邮箱：/^\\w{2,20}@\\w{2, 20}.(com|org|cn|edu)$/.test(数据)</p>\n<p>匹配中文：/^[\\u4e00-\\u9fa5]+$/.test(数据)</p>\n<p>去所有空格：str.replaceAll(' ', '')  或 str.replace(/\\s/g, '')</p>\n<p>购物车去非数字：str.replace(/\\D/g, '')</p>\n<h2>🌟 es6新增语法</h2>\n<p><a href=\"https://github.com/tc39/proposals/blob/main/finished-proposals.md\">https://github.com/tc39/proposals/blob/main/finished-proposals.md</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 2015年 ES6\n\n    修饰符：let、const\n    解构赋值：let {键:变量名=默认值,...,键:变量名=默认值} = {键:值,....,键:值} !!!\n    字符串相关扩展：模板字符串\n    函数相关扩展：箭头函数!!!、函数形参默认值、rest参数 arguments\n    对象相关扩展：对象简写!!!、链判断操作符 ?.  空判断操作符??\n    数组相关扩展：find/findIndex/indexOf/includes\n    新增原始类型：symbol、bigint  \n    -----------\n    //       重要      中等        中等       重要          重要\n    其他新增：展开运算符、新增数据结构、循环forof、module模块化、class类等等\n    \n# 2016年 ES7：Array.prototype.includes\n# 2017年 ES8：Async functions\n# 2018年 ES9：Promise.prototype.finally\n# 2019年 ES10\n# 2020年 ES11：String.prototype.matchAll、import()、BigInt、Promise.allSettled、\n# 2021年 ES12：String.prototype.replaceAll、Promise.any、\n# 2022年 ES13：</code></pre></div>\n<h2>🌟 es6常见问题汇总</h2>\n<ul>\n<li>新增了哪些数据类型：symbol、bigInt</li>\n<li>新增的数据类型属于哪一类：原始类型</li>\n<li>数组如何去重：Set、filter+indexOf、forEach+indexOf、forEach+includes、对象</li>\n<li>新增数据类型有哪些分别有什么用</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Set数组去重\nMap对象的键不限于字符串</code></pre></div>\n<h2>🌟 let、const</h2>\n<p>面试题1：let和const区别</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">相同点-都是块级作用域/不能重复定义\n不同点-let修改/const不能修改</code></pre></div>\n<p>面试题2：const真的不能修改吗</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">原始类型：不可以\n对象类型：可以\n\n原理：const不可以修改栈里面的地址，但是可以修改堆里面的数据</code></pre></div>\n<p>面试题3：暂时性死区</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let前面的区域就是暂时性死区，必须先定义再使用</code></pre></div>\n<p>面试题4：let和const如何选</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">普遍用let、明确后期不改用const 例如Date、xhr、promise对象等\n\nconst d = new Date() </code></pre></div>\n<p>面试题5：var和let区别</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var 函数作用域   可以重复定义 可以修改\nlet 块级作用域  不能重复定义 可以修改</code></pre></div>\n<h2>🌟 bind 和 call/apply 的区别</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fun.call(thisArg, param1, param2, ...)\nfun.apply(thisArg, [param1,param2,...])\n\nfun.bind(thisArg, param1, param2, ...)</code></pre></div>\n<p> <strong>是否立刻执行</strong></p>\n<ul>\n<li><code class=\"language-text\">call/apply</code> 改变了函数的 <code class=\"language-text\">this</code> 上下文后 <strong>马上</strong> 执行该函数。</li>\n<li><code class=\"language-text\">bind</code> 则是返回改变了上下文后的函数, <strong>不执行该函数</strong> 。</li>\n</ul>\n<p><strong>返回值的区别</strong></p>\n<ul>\n<li><code class=\"language-text\">call/apply</code> 返回 <code class=\"language-text\">fun</code> 的执行结果。</li>\n<li><code class=\"language-text\">bind</code> 返回 <code class=\"language-text\">fun</code> 的拷贝，并指定了 <code class=\"language-text\">fun</code> 的 <code class=\"language-text\">this</code> 指向，保存了 <code class=\"language-text\">fun</code> 的参数。</li>\n</ul>\n<h2>🌛 手写bind/call/apply 原理</h2>\n<ul>\n<li>call</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;script>\n  Function.prototype.myCall = function (context, ...args) {\n    context = context ? Object(context) : window\n    context.fn = this\n    let res = context.fn(...args)\n    return res\n  }\n\n  function testFn(data1, data2) {\n    console.log('this：', this)\n    console.log('args：', data1, data2)\n  }\n  let obj = { a: 1, b: 2 }\n  testFn.call(obj, 11, 22)\n  testFn.myCall(obj, 11, 22)\n&lt;/script></code></pre></div>\n<p>apply</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;script>\n  Function.prototype.myApply = function (context, args) {\n    context = context ? Object(context) : window\n    context.fn = this\n    let res = context.fn(...args)\n    return res\n  }\n\n  function testFn(data1, data2) {\n    console.log('this：', this)\n    console.log('args：', data1, data2)\n  }\n  let obj = { a: 1, b: 2 }\n  testFn.apply(obj, [11, 22])\n  testFn.myApply(obj, [11, 22])\n&lt;/script></code></pre></div>\n<p>bind</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;script>\n  Function.prototype.myBind = function (context, ...args1) {\n    context = context ? Object(context) : window\n\n    return (...args2) => {\n      let args = args1.length ? args1 : args2\n      context.fn = this\n      let res = context.fn(...args)\n      delete context.fn\n      return res\n    }\n  }\n\n  function testFn(data1, data2) {\n    console.log('this：', this)\n    console.log('args：', data1, data2)\n  }\n  let obj = { a: 1, b: 2 }\n  let aFn = testFn.bind(obj, 11, 22)\n  let bFn = testFn.myBind(obj, 11, 22)\n  aFn()\n  //  aFn(111,222)\n  bFn()\n  //  bFn(111, 222)\n&lt;/script></code></pre></div>\n<h1>💘 Week4</h1>\n<h2>🌟 原型、原型链概念</h2>\n<p>原型：js给每个函数分配的公共空间，减少内存占用</p>\n<p>原型链：多个原型的集合，当调用对象的属性或方法时，先自身找，找不到去原型链上找，一直找到Object构造函数得原型链</p>\n<h2>🌟 构造函数new干了啥</h2>\n<p>1 搞obj空对象</p>\n<p>2 给obj增加<strong>proto</strong>属性 并且指向 构造函数的.prototype</p>\n<p>3 将 构造函数this中的数据 全部放到obj上</p>\n<p>4 返回obj对象</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// let Sym = fn\nfunction Sym() {\n  this.a = 1;\n  this.b = 2;\n  this.c = 3;\n}\n// 第一种使用方式：当变量赋值用\nlet data1 = Sym;\nconsole.log(data1); // 打印：函数本身\n// 第二种使用方法：当函数用\nlet data2 = Sym();\nconsole.log(data2); // 打印：undefined  但是window多了a、b、c三个属性\n// 第三种使用方法：new关键词\nlet data3 = new Sym();\nconsole.log(\"new关键词：\", data3); // 打印：对象\n\n/*\n栈                  堆\ndata1: 地址1        地址1：function Sym() {  this.a = 1; this.b = 2;  this.c = 3; }\ndata2：undefined    地址2：{a:1,b:2,c:3, __proto__：}\ndata3：地址2\n */\n\nfunction _new(当前new的构造函数) {\n  // let obj = {};\n  // obj.__proto__ = 当前new的构造函数.prototype;\n  \n  let obj = Object.create(当前new的构造函数.prototype); // !!!!\n  //   obj.a = 1;\n  //   obj.b = 2;\n  //   obj.c = 3;\n  当前new的构造函数.call(obj);\n  return obj;\n}\nlet data4 = _new(Sym);\n// 需求：封装_new普通函数仿写new关键词效果\n// 分析：_new普通函数里面做哪些时\n// - 必须返回一个对象\nconsole.log(\"通过_new仿写new：\", data4);</code></pre></div>\n<h2>🌛 箭头函数与普通函数区别？能不能作为构造函数</h2>\n<ol>\n<li>语法更加简洁、清晰</li>\n<li>箭头函数不会创建自己的this</li>\n<li>箭头函数继承而来的this指向永远不变</li>\n<li>.call()/.apply()/.bind()无法改变箭头函数中this的指向</li>\n<li>箭头函数不能作为构造函数使用</li>\n<li>箭头函数没有自己的arguments</li>\n<li>箭头函数没有原型prototype</li>\n<li>箭头函数不能用作Generator函数，不能使用yeild关键字</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844903805960585224##heading-2\">https://juejin.cn/post/6844903805960585224##heading-2</a></p>\n<h2>🌛 更精确判断数据类型</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// typeof 原始类型：除了null是object其他都是自身\n\n// console.log(typeof null); // object\n// console.log(typeof undefined);\n// console.log(typeof true);\n// console.log(typeof 123);\n// console.log(typeof \"sdafadsf\");\n// console.log(typeof Symbol());\n// console.log(typeof 1111n);\n\n// typeof 对象类型：除了function是function其他都是object\n\n// 问题：你就无法根据不同类型做不同逻辑处理\n// 比如：判断是数组  判断是null\n// 解决：Array.isArray()  等等单独处理\n// 然后：也可以统一处理\n\n// 语法：Object.prototype.toString.call(数据)\n\n// console.log(Object.prototype.toString.call(null));\n// console.log(Object.prototype.toString.call(undefined));\n// console.log(Object.prototype.toString.call(true));\n// console.log(Object.prototype.toString.call(123));\n// console.log(Object.prototype.toString.call(\"sdfdsf\"));\n// console.log(Object.prototype.toString.call(Symbol()));\n// console.log(Object.prototype.toString.call(1111n));\n// console.log(Object.prototype.toString.call(function () {}));\n// console.log(Object.prototype.toString.call({}));\n// console.log(Object.prototype.toString.call([]));\n\nfunction getType(data) {\n  let result = Object.prototype.toString.call(data);\n  //   console.log(result.substr(8, result.length - 1 - 8));\n  console.log(result.slice(8, -1));\n}\n\ngetType(null);\ngetType(undefined);\ngetType(true);\ngetType(123);\ngetType(\"sdfdsf\");\ngetType(Symbol());\ngetType(1111n);\ngetType(function () {});\ngetType({});\ngetType([]);</code></pre></div>\n<h2>🌛 Object构造函数上有哪些语法</h2>\n<p>重要</p>\n<p>Object.defineProperty()     三阶段才详细讲  现在【禁止】百度这个</p>\n<p>Object.keys()     获取对象的所有键 返回数组</p>\n<p>Object.values()    获取对象的所有值 返回数据</p>\n<p>Object.create()    创建对象（特色 基于指定原型造对象     场景1：new原理优化，场景2：三阶段vue ）</p>\n<hr>\n<p>Object.assign()   合并对象</p>\n<p>Object.prototype.constructor    所属构造函数</p>\n<p>Object.prototype.toString()    转字符串 </p>\n<h1>💘 Week5  高频周</h1>\n<h2>- day1</h2>\n<h2>🌟 输入网址浏览器干哈了（简单版）</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">打开浏览器输入网址回车 ->  去DNS服务器找网址对应的IP地址 -> 找不到【无法访问此网站】 找到了【根据ip地址去请求服务器】 -> 服务器返回数据 -> 【浏览器解析】\n\n脚下留心：浏览器其实返回的是index.html的数据，然后在解析的过程中，遇到link、script、img等 再次发送请求拿数据然后解析</code></pre></div>\n<h2>🌟 谈谈你对HTTP理解</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">面试：HTTP是超文本传输协议，规定了客户端和服务端如何通信，然后由两个部分组成分别是请求、响应\n\n学习：就是一个规则，你必须按照这个规则才可以和后端交互拿数据</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">概念：超文本传输协议\n作用：规定客户端和服务端通信技术\n场景：网页、APP等\n请求组成：请求行（地址/状态吗/请求方式）、请求头（ua、content-type、token、cookie）、请求体（接口参数）\n响应组成：响应行（同上）、响应头（暂略）、响应体（接口数据调试错误）</code></pre></div>\n<h2>🌟 HTTP周边：HTTP动词</h2>\n<h2>🌟 HTTP周边：状态码</h2>\n<h2>🌟 HTTP周边：请求头参数</h2>\n<ul>\n<li>HTTP动词（请求方式 method)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">明确：form标签也就是w3c就是遵循http规则设计的  但是它的请求方式仅仅只有两种get、post 其他不支持\n但是：我们目前也用get、post 等到三阶段就用n多\n然后：面试就问你有哪些\n种类：常用的get查询、post增加数据、put修改数据、delete删除数据\n实际：java攻城狮就用get查询 增删改都用post</code></pre></div>\n<ul>\n<li>状态码</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2xx  200 成功  201 成功并且服务器创建了新数据\n3xx  301 站内跳转   302 站外跳转   304  浏览器缓存\n4xx  400 你传递给后端的参数   401 密码错误  403 没有权限  404文件不存在  405 请求方式有误\n5xx  500 服务器有误</code></pre></div>\n<ul>\n<li>请求头参数</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ua、content-type、token、cookie</code></pre></div>\n<h2>🌟 HTTP周边：强制缓存、协商缓存</h2>\n<p>强制缓存：就是文件直接从本地缓存中获取，不需要发送请求。</p>\n<blockquote>\n<p>响应头  Cache-Control : 86400</p>\n<p>expires</p>\n</blockquote>\n<p>协商缓存/对比缓存  </p>\n<blockquote>\n<p>在响应头部 <code class=\"language-text\">Response Headers</code> 中，<strong>有两种资源标识：</strong></p>\n<ul>\n<li><code class=\"language-text\">Last-Modified</code> 资源的最后修改时间，对应请求头为 <code class=\"language-text\">If-Modified-Since</code> ；</li>\n<li><code class=\"language-text\">Etag</code> 资源的唯一标识，所谓唯一，可以想象成时人类的指纹，具有唯一性；但 <code class=\"language-text\">Etag</code> 的本质是一个字符串；对应请求头为 <code class=\"language-text\">If-None-Match</code> 。</li>\n</ul>\n<p><strong>Last-Modified 和 Etag</strong></p>\n<ul>\n<li>当响应头部 <code class=\"language-text\">Response Headers</code> 同时存在 <code class=\"language-text\">Last-Modified</code> 和 <code class=\"language-text\">Etag</code> 的值时，会优先使用 <code class=\"language-text\">Etag</code> ；</li>\n<li><code class=\"language-text\">Last-Modified</code> 只能精确到秒级；</li>\n<li>如果资源被重复生成，而内容不变，则 <code class=\"language-text\">Etag</code> 更精确。</li>\n</ul>\n<p><a href=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F5727550-fd8811d7defb8956.png&#x26;refer=http%3A%2F%2Fupload-images.jianshu.io&#x26;app=2002&#x26;size=f9999,10000&#x26;q=a80&#x26;n=0&#x26;g=0n&#x26;fmt=auto?sec=1650391279&#x26;t=0419cce2bf932f3c0e83594c4d177742\">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F5727550-fd8811d7defb8956.png&#x26;refer=http%3A%2F%2Fupload-images.jianshu.io&#x26;app=2002&#x26;size=f9999,10000&#x26;q=a80&#x26;n=0&#x26;g=0n&#x26;fmt=auto?sec=1650391279&#x26;t=0419cce2bf932f3c0e83594c4d177742</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">请求行/响应行：method、url、status\n\n请求头headers、cookie、content-type、ua、if-none-match、if-modified-since \n请求体：请求参数\n\n响应头：content-type 告诉浏览器如何解析数 、etag、last-modified、 Cache-Control...\n响应体：响应的数据</code></pre></div>\n<h2>🌟 get和post有什么区别</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">安全角度：post相对比get安全    原因get会在地址栏 因为在地址栏就有访问历史记录  post请求体不会存在来留痕\n数据角度：post相对传输的数据比get多      get会受到不同浏览器地址栏长度限制，post服务器配置\n\n\n上传图片：2M 一般只能上传png、jpg  gif不允许</code></pre></div>\n<h2>🌟 谈谈你对http、https的理解，有什么区别</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http超文本通讯协议\t80\nhttps也是超文本通讯协议  相对http更加安全  443</code></pre></div>\n<h2>-day2</h2>\n<h2>🌟 谈谈你对骨架屏的理解</h2>\n<p>骨架屏就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页等相对比较规则的列表页面。 很多项目中都有应用:ex:饿了么h5版本,知乎,facebook等网站中都有应用。</p>\n<p>参考</p>\n<p><a href=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/15/16676db12e4232bb~tplv-t2oaga2asx-watermark.awebp\">https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/15/16676db12e4232bb~tplv-t2oaga2asx-watermark.awebp</a></p>\n<h2>🌟 谈谈你对节流防抖的理解</h2>\n<p>回答：节流防抖都是用来进行项目优化，减少代码触发的频率，同时又不影响实际效果\n节流：一段时间内只执行一次\n防抖：一段时间内可重复执行，但是要把之前的取消掉</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">思路：事件中代码用定时器包起来，然后再前面加判断\n\n问题：输入教主会执行 jiaozhu教主 这么多次\n标签对象.oninput = function() {\n    console.log(1)\n}\n\n节流：一段时间内 1次\nlet t\n标签对象.oninput = function() {\n    if (t) return\n    t = setTimeout(() => {\n        console.log(1)\n        t = null\n    }, 3000)\n} \n\n防抖：一段时间内可重复执行，但是要把之前的取消掉\nlet t\n标签对象.oninput = function() {\n    if (t) clearTimeout(t)\n    t = setTimeout(() => {\n        console.log(1)\n        t = null\n    }, 3000)\n}</code></pre></div>\n<h2>🌟 谈谈你对高阶函数的理解</h2>\n<p>简而言之，高阶函数是那些将其他函数作为参数或返回其他函数的函数。在高阶函数中作为参数传递的函数被称为回调。</p>\n<p>高阶函数的优势：</p>\n<ul>\n<li>它们可以帮助我们写出简洁的代码。</li>\n<li>由于是简洁的代码，调试工作会更加容易。</li>\n</ul>\n<p>现在 JavaScript 有一些内置的高阶函数，你可能已经在不知不觉中就使用它们了，例如 <code class=\"language-text\">filter()</code>、<code class=\"language-text\">reduce()</code>、<code class=\"language-text\">sort()</code> 和 <code class=\"language-text\">forEach()</code>。</p>\n<h2>🌟 function+ajax+callback</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/**\n * 发送get异步请求\n * @param {stirng} url 请求地址\n * @param {object} params 请求参数，格式  {参数名:数据,....,参数名:数据}\n * @param {function} callback 回调函数\n * @param {object} headers 自定义请求头   {键:值, token: '数据', 'content-type': '数据'}\n */\nfunction get(url, params, callback, headers = {}) {\n  // 一、创建xhr对象\n  const xhr = new XMLHttpRequest();\n  // 二、设置请求方式、请求地址\n  let temp = [];\n  for (let key in params) {\n    temp.push(`${key}=${params[key]}`);\n  }\n  xhr.open(\"get\", `${url}?${temp.join(\"&amp;\")}`);\n  // 三、监听请求状态\n  xhr.onreadystatechange = () => {\n    // 判断返回\n    if (xhr.readyState === 4) {\n      // 判断状态\n      if (xhr.status === 200) {\n        // 获取数据\n        let res = JSON.parse(xhr.responseText);\n        // 逻辑处理\n        // console.log(res);\n        callback(res);\n      } else {\n        console.log(xhr.status);\n      }\n    }\n  };\n  // 四、发送\n  for (let key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n  xhr.send();\n}</code></pre></div>\n<h2>🌟 function+ajax+promise</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/**\n * 发送get请求\n * @param {stirng} url 请求地址\n * @param {object} params 请求参数\n * @param {object} headers 自定义请求头\n * @returns \n */\nfunction get(url, params, headers = {})\n{\n    const p = new Promise((resolve, reject) => {\n        // 一、创建xhr对象\n        const xhr = new XMLHttpRequest\n        // 二、设置请求方式、请求地址\n        let temp = []\n        for (let key in params) {\n            temp.push(`${key}=${params[key]}`)\n        }\n        xhr.open('get', `${url}?${temp.join('&amp;')}`)\n        // 三、监控请求状态\n        xhr.onreadystatechange = () => {\n            // 返回\n            if (xhr.readyState === 4)\n            {\n                // 状态码\n                if (xhr.status === 200)\n                {\n                    // 获取数据\n                    let res = JSON.parse(xhr.responseText)\n                    // 逻辑处理\n                    // console.log(res)\n                    resolve(res)\n                } else {\n                    // console.log(xhr.status)\n                    reject(xhr.status)\n                }\n            }\n        }\n        // 四、发送请求\n        for (let key in headers) {\n            xhr.setRequestHeader(key, headers[key])\n        }\n        xhr.send()\n    })\n\n    return p  // 后期谁调用get就会拿到promise对象 通过then就可以获取数据 实现不同的业务逻辑\n}</code></pre></div>\n<h2>-day3</h2>\n<h2>🌟 谈谈你对promise的理解</h2>\n<p>概念：ES6异步编程解决方案</p>\n<p>作用：常用于封装ajax异步请求</p>\n<h2>🌟 说一下promise原理</h2>\n<p>底层创建了Promise构造函数，并且给该构造函数绑定了then、catch、finally等原型方法，和reject、resolve、all、race等静态方法。</p>\n<h2>🌟 说一下promise几个状态</h2>\n<p>进行中、成功了、失败了</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const p = new Promise((resolve, reject) => {\n\t// 发送异步请求\n\t// 默认触发的  所以是进行中状态\n})</code></pre></div>\n<p>追问：为什么状态不可逆</p>\n<p>回答：底层Promise构造函数中会判断当前是否是pending进行中状态，不是就会终止代码执行  所以不可逆</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 明确：底层Promise源码大概是这么写的\nfunction Promise(callback) {\n\n    this.PromiseState = 'pending'\n    this.PromiseResult = undefined\n    \n    const resolve = data => {\n        if (this.PromiseState != 'pending') return\n        this.PromiseState = 'fulfilled'\n        this.PromiseResult = data\n    }\n    const reject = error => {\n        if (this.PromiseState != 'pending') return\n        this.PromiseState = 'rejected'\n        this.PromiseResult = error\n    }\n\n    try {\n        // callback(参数1, 参数2)\n        // callback(() => {}, () => {})\n        callback(resolve, reject)\n    } catch(error) {\n        reject(error.toString())\n    }\n}\n\n// 然后：你写\nconst p = new Promise((resolve, reject) => {\n\tresolve(数据1)\n\treject(数据2)\n})</code></pre></div>\n<p>追问：状态之间怎么转换？</p>\n<p>回答：通过promise的then机制，来实现状态切换</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const p = new Promise((resolve, reject) => {\n\tresolve(数据1)\n})\n\np\n.then(res => {\n\treturn Promise.resolve('失败的')\n})</code></pre></div>\n<h2>🌟 Promise.all、Promise.allSettled区别</h2>\n<p> Promise.all( 数组里面是一个个Promise对象 )     有一个失败就走失败</p>\n<p> Promise.allSettled( 数组里面是一个个Promise对象 )      没有失败</p>\n<h2>🌟 Promise.race、Promise.any区别</h2>\n<p> Promise.race( 数组里面是一个个Promise对象 )    根据第一个最快返回的决定状态</p>\n<p> Promise.any( 数组里面是一个个Promise对象 )     有一个成功就是then 都失败 才是catch</p>\n<h2>- day4</h2>\n<h2>🌟 跨域相关</h2>\n<ul>\n<li>跨域导致原因</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">概念：当请求一个url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域\n原因：浏览器安全策略/同源策略\n后果：不能跨网站操作发送ajax请求、WEB存储等</code></pre></div>\n<ul>\n<li>跨域解决方案</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">前端  \n前端代理  http-proxy-middleware \n谷歌插件 \n谷歌命令\n\njsonp\n\nwebsocket\npostMessage \n\n\n留心：上述不管哪种方式仅自己可以使用\n最终：开发就选上面其中一种，最终后端：cors法  原理响应头告诉浏览器任何人都可以使用；nginx 反向代理 </code></pre></div>\n<h2>🌛 谈谈你对同步异步的理解</h2>\n<p>会被加入到浏览器队列的代码称之为异步代码，例如  ajax、setTimeout/setInterval、Promise.then 等等，他们不按书写✍🏻顺序执行打印结果的代码</p>\n<p>按照书写顺序执行打印的代码称之为同步代码</p>\n<h2>🌟谈谈你对async，await的理解</h2>\n<p>async、await是generator的语法糖，通过async修饰function、await修饰promise，</p>\n<p>底层将await后面的表达式会先执行一遍，再将await下一行代码加入到微任务中。</p>\n<h2>🌛 谈谈你generator的理解</h2>\n<p>es6新增的语法，通过*号修饰函数，当调用函数的时候返回一个generator对象，通过next函数迭代获取函数内部的数据，当遇到yield就会暂停，再次写next才会继续</p>\n<h2>🌟 说出浏览器运行机制</h2>\n<p>浏览器主进程，负责创建和销毁tab进程、负责交互前进后退、负责网页文件下载等\n渲染进程：每个tab对应一个渲染进程，下面有GUI渲染线程、JS引擎线程、事件线程、定时器线程、异步请求线程\nGPU进程：负责3D图绘制\n第三方插件进程：负责第三方插件处理，例如跨域、广告拦截插件等</p>\n<h2>🌟 说出浏览器输入网址干了啥</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">浏览器输入网址回车\n去DNS服务器找网址对应的IP地址 \n根据IP地址加端口访问服务器软件 \n服务器返回数据\n浏览器通过renderer是渲染进程处理，\n其中GUI线程负责页面渲染、JS引擎线程负责解析JS代码</code></pre></div>\n<h2>🌛 说出JS为什么是单线程</h2>\n<blockquote>\n<h3>先看一个比喻</h3>\n<p>进程就是一个公司，每个公司都有自己的资源可以调度；公司之间是相互独立的；而线程就是公司中的每个员工(你，我，他)，多个员工一起合作，完成任务，公司可以有一名员工或多个，员工之间共享公司的空间</p>\n<h3>什么是进程？</h3>\n<p>进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</p>\n<h3>什么是线程？</h3>\n<p>线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n<h4>浏览器是多进程的</h4>\n<p>放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。</p>\n<h3>大家都在说js是单线程的，但是为什么要设计成单线程？</h3>\n<p>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变.</p>\n<h4>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</h4>\n</blockquote>\n<h2>🌛 说出JS是单线程 为什么不存在执行效率问题</h2>\n<p>JS是单线程执行程序代码，形成一个执行栈，挨个处理；</p>\n<p>但是遇到特别耗费时间的代码 ，例如异步请求，事件等，</p>\n<p>不会堵塞等待执行，而是交给浏览器其他线程处理后，再丢到执行栈中处理，从而保证还行效率</p>\n<h2>🌟 谈谈你对Event Loop的理解</h2>\n<p><code class=\"language-text\">Event Loop</code>即事件循环，</p>\n<p>是指浏览器或<code class=\"language-text\">Node</code>的一种确保javaScript单线程运行时不会阻塞的一种机制，</p>\n<p>也就是我们经常使用<strong>异步</strong>的原理。    </p>\n<p>种类：浏览器的Event Loop、Node.js中的Event Loop</p>\n<h2>🌟 谈谈你对浏览器的Event Loop理解</h2>\n<p>浏览器输入网址服务器响应数据后，</p>\n<p>浏览器会通过render进程开始解析工作</p>\n<p>GUI线程负责页面渲染</p>\n<p>JS引擎线程负责执行JS代码</p>\n<p>遇到异步代码会交给其他线程处理，然后放到队列中，</p>\n<p>事件循环主要是从队列中取出代码放到执行栈中交给js引擎线程处理</p>\n<h2>🌟 说出宏任务、微任务各有哪些</h2>\n<blockquote>\n<p>单词含义：I input 输入、 O output 输出 </p>\n<p>用户角度IO操作：鼠标键盘-是计算机输入信息，显示器-是输出设备</p>\n<p>电脑角度IO操作：CPU、内存与其他设备之间数据转移过程就是IO操作，例如数据从磁盘读到内存，或者内存写到磁盘</p>\n<p>编程角度IO操作：进程读取数据操作</p>\n</blockquote>\n<ul>\n<li>宏任务：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">整体代码（script）\n定时器（setTimeout、setInterval）\nI/O操作（DOM事件、AJAX异步请求）\n\nsetImmediate（node环境）\nrequestAnimationFrame（浏览器环境）</code></pre></div>\n<ul>\n<li>微任务 </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Promise.then catch finally\nasync/await（底层还是promise）\nprocess.nextTick（node环境） \nMutationObserver（浏览器环境）</code></pre></div>\n<h2>🌟 说出先执行宏任务还是微任务</h2>\n<p>算整体代码script：1宏n微</p>\n<p>不算整体代码script：先n微，再1宏 ->  n微，再1宏 ->  n微</p>\n<h2>- day5</h2>\n<h2>🌛 前端存储有几种</h2>\n<p>回答1：常用的2种，主要是cookie、h5存储；浏览器其实还有web sql、indexdb</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">H5\ncookie\nweb sql\nindexdb</code></pre></div>\n<h2>🌟cookie和h5的区别</h2>\n<p>回答2：答案在下面</p>\n<blockquote>\n<p>性能角度：相对而言H5存储性能比COOKIE高</p>\n<p>存储空间：H5单条数据5M左右、COOKIE单条数据4KB</p>\n<p>生命周期： </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cookie \t\t\t       自己设置，如果不设置浏览器关闭销毁\nh5 localStorage    永久\nh5 sessionStorage  窗口 </code></pre></div>\n</blockquote>\n<h2>🌟如何实现localStorage7天过期</h2>\n<p>回答3：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cookie.  1*1000*60*60*24*7\n\n\nlogin.html\n\n步骤1：存数据的时候 也额外存一个键叫 expires  记录时间\n\tlocalStorage.setItem('uname', 'value')\n\tlocalStorage.setItem('expires', (new Date).getTime() + 1*1000*60*60*24*7 )\nmember.html\n步骤2：使用的时候增加判断\n\t// 公式：当前使用时间 > 存储时间 （过期了）\n\t// 举例：比如你是2月1号存 \n\t// 然后：你加了7天  2月8号过期\n\t// 最后： 2月5号 > 2月8号   不成立 没过期\n\t// 最后： 2月11号 > 2月8号  成立  过期</code></pre></div>\n<h2>🌟如何实现七天免登录</h2>\n<p>1、登录的时候存一个时间       当前时间+7天时间戳</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">localStorage.setItem('uname', 'value')\nlocalStorage.setItem('expires', (new Date).getTime() + 1*1000*60*60*24*7 )</code></pre></div>\n<p>2、后期用的时候判断是否过期</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;h1>会员中心&lt;/h1>\n\n&lt;div>&lt;/div>\n\n&lt;script>\n// 获取\n// let localUname = localStorage.getItem('uname')\n// 明确：上一行代码有瑕疵\n// 因为：永久\n// 解决：加时间判断\n// let localUname = 当前时间>存储时间 ? 过期了null : 没过期使用\n// 分析：\n// 存储时间：今天8.1登录 存7天   8.8不可以\n// 当前时间：8.1    8.3   8.6   8.9\n\nlet localUname = (new Date).getTime()>localStorage.getItem('expires') ? null : localStorage.getItem('uname')\nlet sessionUname = sessionStorage.getItem('uname')\n\nlet uname = localUname || sessionUname\n// 判断\nif (uname)\n{\n    document.querySelector('div').innerHTML = `&lt;h1>${uname}&lt;/h1>&lt;a href=\"./logout.html\">退出&lt;/a>`\n} else {\n    document.querySelector('div').innerHTML = `&lt;a href=\"./login.html\">登录&lt;/a>`\n}\n&lt;/script></code></pre></div>\n<h2>🌟登录是如何实现的</h2>\n<p>步骤1：登录按钮绑定点击事件</p>\n<p>步骤2：事件处理函数中  获取表单数据，请求接口</p>\n<p>步骤3：失败-弹框提示，成功-提示、存储、跳转</p>\n<h2>...</h2>\n<h1>💘 Week6  较为低频</h1>\n<h2>🌛 xhr、$.get、$.ajax区别</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">问题1：XMLHttprequest和JQ代码的区别\n回答1：\n相同点：都可以发送异步请求\n不同点：JQ是基于XMLHttprequest封装了  1 更简单、 2 解决兼容问题等\n\n问题2：$.get、$.ajax区别\n回答2：一样，唯一区别$.ajax比$.get语法上更强</code></pre></div>\n<h2>🌛 jq你会吗，比如操作样式用什么属性...</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">获取标签：CSS选择器、筛选选择器、过滤选择器等\n操作标签：样式css方法、类addClass、属性attr/prop、内容val/html、节点append/remove\n事件：$().事件类型()     $().on(事件类型，子，处理函数)\n异步请求：$.get、$.post、$.ajax\n动画：$.animate() \n网页加载完毕：$(function(){})    （留心：和window.onload区别 \n对象相互转换：$()[索引]   或者  $(JS标签对象</code></pre></div>\n<h1>💘 Week7  高频</h1>\n<h2>🌟 说出几个常用的git命令</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">配置SSH  ssh-keygen\n用户配置  git config global user.name/email ''\n获取代码 \ngit clone 仓库地址\ngit init \ngit remote add origin 仓库地址\ngit remote remove origin 仓库地址\n增删改：git add . / commit  / push\n\n周边（忽略文件） .gitignore\n周边（代码冲突） git pull git status \n周边（日志回滚   git log 、 git reset \n周边（分支）    git branch / git checkout ...\n周边（其他）    git stash、git tag、git pull、git fetc、git merge</code></pre></div>\n<h2>🌟 说出git工作流，说一下你们日常开发工作流</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git flow\n\n功能分支 -> 合并到dev分支\ndev分支 -> 合并到release分支\nrelease分支 -> 合并到master分支</code></pre></div>\n<h2>🌟 说下git如何解决代码冲突</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 pull\n2 status、手动解决\n3 重新add/commit/push</code></pre></div>\n<h2>🌟 说一下你在开发登陆时，线上出现bug了如何维护</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">基于master创建hotfix分支，\n解决了再 push 并 merge 到 master、dev 上</code></pre></div>\n<h2>🌟 克隆获取的是默认分支代码，如何获取其他分支代码</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout -b 分支名 分支名</code></pre></div>\n<h2>🌟 用过哪些git图形化可是软件</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">编辑器\nsourcetruee  \n等等</code></pre></div>\n<h2>🌟 说下git和svn区别</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git是分布式、svn是集中式\nsvn相对容易冲突\n等</code></pre></div>","timeToRead":32}},"pageContext":{"slug":"posts/阶段二面试题/","previousPost":{"fields":{"slug":"posts/阶段三VUE面试题/"},"frontmatter":{"title":"第三阶段Vue面试题"}},"nextPost":{"fields":{"slug":"posts/阶段一面试题/"},"frontmatter":{"title":"阶段一面试题"}}}},"staticQueryHashes":["3344698684","3792814546"]}