---
layout: post
title: 面试题（重点）(li)
description: >-
 面试题（重点）(li)!
date: '2021-02-03 05:57:55'
thumbnail: assets/img/Captura de Tela 2021-02-03 às 19.12.24.png
category: Dev
background: '#CD4C51'
---

##### 1、盒子模型？弹性盒子的理解？

```css
盒子模型：
（1）两种，IE 盒子模型、标准 W3C 盒子模型；IE 的 content 部分包含了 border 和pading;
（2）盒模型：内容(content)、填充(padding)、边界(margin)、 边框(border).

弹性盒子：
弹性盒模型(flexbox)又称为弹性布局，是css3中新提出的一种布局方式，引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。



```



##### 2、CSS3动画样式transition、transform、animation之间的区别？

```css


transform：1. transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。
          2. transform属性是静态属性，需要配合transition和animation才能展现出动画效果。你可以把它看成是跟left、top等属性一样，只是一个静态样式而已。

animation：一个css3的动画属性，需要配合@keyframes 使用

区别： 1. transition是css中检测指定属性变化进行自动补间动画的属性。
      2. animate是先指定好动画过程中的关键帧属性，进行动画的属性。

transition:过渡动画，常用参数：过渡一个属性all,延迟时间，动画时间，执行动画效果linear
transform：位移动画，scale、translate、skew、rotate
animation：执行动画，需要和@keyframe配合使用
```

##### 3、样式居中有哪些方式？

```
给父元素相对定位
给子元素绝对定位，并且：
left: 50%;top: 50%;
margin-left: 负的宽度一半。
margin-top: 负的高度一半；


使用display:flex；
justify-content：center；
align-items：center；


使用定位的方式
父元素设置为：position: relative;
子元素： position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
        
        
定位translate
父元素设置为：position: relative;
子元素： position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);        
```



##### 4、对定位(position)的理解，默认值、absolute、fixed、relative的区别？

```css
relative：相对定位，根据right；top；left；bottom等属性，相对自己原来的位置偏移，原位置还会占位置。添加给父元素做辅助作用

absolute：绝对定位，不占位置 父元素有定位属性根据父元素位置来定位自己的位置，父元素没有根据html定位

fixed（老 IE 不支持）：固定定位，不占位置，根据浏览器的窗口(html)来定义自己的位置
```



##### 5、CSS选择器优先级？

```css
!important > id > class > 标签
!important 比 内联优先级高

优先级就近原则，样式定义最近者为准;
以最后载入的样式为准;
```



##### 6、rem、em、px之间的区别？

```css
px（像素）：页面默认的尺寸计算单位，绝对长度,它是相对于显示器屏幕分辨率而言的
    特点：1. IE无法调整那些使用px作为单位的字体大小
         2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；
         3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。

em：相对长度，相对于应用在当前元素的字体尺寸；一般浏览器默认字体大小为16px，则 1em = 16px
    特点：1. em的值并不是固定的；
         2. em会继承父级元素的字体大小。

rem（root em）：相对单位，相对于html根元素字体大小的单位，当html的font-size：16px时，1rem = 16px
    特点：1. 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。
		2. 除了IE8及更早版本外，所有浏览器均已支持rem。


为什么给font-size设置为62.5%： 方便换算！
    1. 因为绝大多数浏览器的默认字体大小为 16px ，而将font-size设置为 62.5% 则等价于字体大小的font-size:10px;
    2. 随之在其他的换算单位，如 rem 的字体换算时，则可以表示为 1rem = 10px， 整数值对于单位的换算会比较方便
    3. 但是在Chrome（谷歌浏览器）中，支持最小字体的大小为 12px ，解决办法就是 将html根字体设置为 font-size: 625%; 意：1rem = 100px ，以此单位换算
```



##### 7、输入URL地址到页面渲染出来都处理了哪些事情？

```css
1、浏览器输入 url。先解析 url 地址是否合法
2 浏览器检查是否有缓存（浏览器缓存 - 系统缓存 - 路由器缓存）。如果有，直接显示。如果没有，跳到第三步。
3. DNS解析 解析获取对应过的 ip 地址
4. TCP连接(三次握手)
5. 客户端向服务端发送http请求  请求数据包
6. 服务器处理请求，返回http报文
7、浏览器解析响应。如果响应可以缓存，则存入缓存
8.浏览器发送请求获取嵌入在 HTML 中的资源（html，css，JavaScript，图片，音乐等），对于未知类型，会弹出对话框
9、浏览器发送异步请求
10. 页面全部渲染结束
```

![image-20220607085629973](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20220607085629973.png)



##### 8、浏览器渲染的基本原理？

```css
浏览器将获取的html文档解析成dom树
处理css标记，构成层叠样式表模型CSSOM  （css、object  model）
将DOM和CSSom合并为渲染树  （将要被渲染的对象）
渲染树的玫瑰元素包含的内容都是计算过的，浏览器使用一种流失处理的方法，只需要一此pass会在操作就可以布局所有的元素
将渲染树的节点渲染到页面上 这一步
```



##### 9、let、const、var定义变量有什么区别？

```css
1、var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。有变量提升
2、let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。没有变量提升
3、const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。没有变量提升
```



##### 10、call、apply、bind有什么区别？

```css
call方法call()是apply()的一颗语法糖，作用和apply()一样，同样可实现继承，唯一的区别就在于call()接收的是参数列表，而apply()则接收参数数组。

bind方法bind()的作用与call()和apply()一样，都是可以改变函数运行时上下文，区别是call()和apply()在调用函数之后会立即执行，而bind()方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用 不会立即执行       call 传对象。 apply 传数组    
```



##### 11、JS的基础数据类型有哪些？null和undefined有什么区别？

```css
string  Number  Boolean   null   undefined    es6新增的   symbol    Bigint

null     定义了类型但是赋的值为空  

undefined ：1、  函数没有返回值，默认返回undefined、

​	   2、调用函数时，应该提供参数没有提供，那么这个参数就等于undefined

​	   3、当前对象没有赋值的属性，那么此属性的值就为undefined
```



##### 12、JS的原型链是什么？怎么使用它来实现继承？

```css
原型链：每一个构造函数都有一个原型对象，每一个原型对象都包含一个构造函数，每个实例都包含一个原型对象
prototype （普若图泰普）
继承：对象实例通过原型链的方式串联起来，当访问目标的某一属性时，就能通过原型链查找。达到继承的效果 （原型链继承关键步骤在与：将子类原型和父类原型关联起来，使原型链能够连接上，将子类原型指向父类来实现关联）
```



##### 13、JS继承有哪些方式？

```css
1.原型链继承 
2.借用构造函数继承   call/apply  把this重新指向
3.组合继承(原型+借用构造) 
4.原型式继承 
5.寄生式继承 
6.寄生组合式继承
```



##### 14、页面的重排、重绘有什么区别？回流机制是什么？

```js
重排： 如果我们的盒子发生了变化（宽度、高度、内边距、外边距、字体等发生了变化，那么需要重新布局，就会引起重排）。重排一定会引起重绘
重绘：完成重排后，浏览器会重新绘制把受影响的部分到浏览器上，这个过程就成为重绘，重排必然会引发重绘。 页面重绘不一定会重排   

回流就是重排




```



##### 15、样式的link和@import引入有什么区别？

```css
link属于html 标签，而@import是CSS中提供的 在页面加载的时候，link会同时被加载，而@import引用的CSS会在页面加载完成后才会加载引用的CSS
 
@import只有在ie5以上才可以被识别，而link是html标签，不存在浏览器兼容性问题
   link引入样式的权重大于@import的引用（@import 是将引用的样式导入到当前的页面 中）
    
link支持使用Javascript控制DOM去改变样式；而@import不支持
link可以引入任何资源 @import只能在css文件中引入css文件
link是同步的 。@import是异步的。    
```



##### 16、如何理解Promise、Promise.all、Promise.race这之间的区别？

```css
1、promise 可以避免出现回调地狱 后期维护方便

2、promise.all 属于同步执行，数据全部返回后才会显示  
    all。如果有一个错误返回会怎么样。 如果有任何一个错误，那么只会在catch里面获取到这个错误请求

3、promise.race 属于异步操作，不管成功还是失败，那个执行完成就先返回那个值
			race赛跑机制，只接受第一个返回的结果
```



##### 17、如何理解闭包？它有什么优缺点？

```css
含义：外部函数  内部定义一个内部函数，内部函数使用的外部函数的局部变量，外部函数返回了内部函数
主要是避免数据全局污染，所以对数据盒操作数据的方法进行封装
优点：
	希望一个变量长期存储在内存中。
	避免数据全局变量的污染。
	私有成员的存在。
缺点：
	常驻内存，增加内存使用量。
	使用不当会很容易造成内存泄露。
	过度使用闭包会引起内存泄露

```



##### 18、JS对象的深浅拷贝都是什么？有哪些实现方式？

```css
深拷贝:拷贝的是对象或者数组内部数据的实体，重新开辟了内存空间存储数据；
浅拷贝:拷贝的是引用类型的指针，副本和原数组或对象指向同一个内存；

浅拷贝：....展开运算符、for循环做拷贝，jQuery.data方法也可以进行拷贝,ladash.clone
	
深拷贝：for递归循环、JSON.parse（JSON.stringify(a)）函数和undefined会丢失,lodash.clonedeep

```



##### 19、数组去重有哪些方式？

```js
1、Set  +基础数据类型  不能对对象去重   为ES6新增的一个对象，允许存储任何类型（原始值或引用值）的唯一值
2、使用双重for循环，再利用数组的splice方法去重
3、利用数组的indexOf 需要加for 方法去重   
   //注：array.indexOf(item,statt) 返回数组中某个指定的元素的位置，没有则返回-1
4、利用数组的sort方法去重（相邻元素对比法
   //array.sort( function ) 参数必须是函数，可选，默认升序
5、利用对象的属性不能相同的特点去重
   //用数组项作为对象的属性会自动去除相同的值
6、利用数组的includes去重
   //arr.includes(指定元素(必填),指定索引值(可选,默认值为0) )，有值返回true，没有则返回false
7、利用数组的filter方法去重
  //filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，
8、利用函数递归去重
9、利用ES6中的Map方法去重
```



##### 20、判断数据都有哪些方式？

```css
1、typeof 太破欧服
	返回基础数据类型
2、instanceof   因丝腾此 欧服

	用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true，否则返回false。instanceof检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。
3、constructor  肯丝爪可它

	当一个函数F被定义时，JS引擎会为F添加prototype（坡的太铺）原型，然后在prototype上添加一个constructor属性，并让其指向F的引用，F利用原型对象的constructor属性引用了自身，当F作为构造函数创建对象时，原型上的constructor属性被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。
	这样做的意义是，让对象诞生以后，就具有可追溯的数据类型。
												
4、Object.prototype.toString().call()
	toString()是Object的原型方法，调用该方法，默认返回当前对象的类型，格式是[object,xxx],对于Object对象，直接调用toString()就能返回[object Object],而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。	
```



##### 21、堆栈的区别？

```css
堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，
堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，
堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化

栈：是内存中存储值类型的，大小为2M，超出则会报错，内存溢出
```



##### 22、for...in 和 Object.keys 有什么区别？

```css
Object.keys 
只能遍历自身的属性  不会遍历原型链上的属性   
1.遍历结果为对象自身属性组成的数组，数组中的属性名排列顺序与使用for in循环遍历该对象时返回的顺序一致，
2.与for in区别在于不能遍历出原型链上的属性；

for...in 
遍历所有属性
1.作用于数组的for in除了会遍历数组元素外,还会遍历自定义的属性,以及原型链上的属性;
2.作用于数组的for in的遍历结果是数组的索引,且都为字符串型,不能用于运算;
3.某些情况下,可能按照随机顺序遍历数组元素;
```



##### 23、变量提升如何理解？var 和 function提升有什么区别？

```css
在变量的作用域内，不管变量在何处声明，都会被提升到作用域的顶部，但是变量初始化的顺序不变.

使用var定义变量，声明的变量会提升到作用域顶部，但是赋值操作并不会提升；使用function声明函数，整个声明语句都会得到提升。所以声明提升提升的是对函数或变量的声明，而不是赋值！

```



##### 24、事件捕获和冒泡？事件委托是什么原理？

```css
事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。
事件冒泡：当事件发生后，这个事件就要开始传播（从里向外或者从外向里）。
事件委托原理：事件委托是利用了冒泡，通过委托可以减少事件绑定的次数，提高程序的性能。
```



##### 25、new 关键字都执行了哪些业务？

```css
1.创建一个新对象
2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
3.执行构造函数中的代码（为这个新对象添加属性）
4.返回新对象
```



##### 26、JS中有哪些操作会引起内存泄露？

```css
意外的全局变量引起的内存泄露
2、闭包引起的内存泄漏
3、没有清理的 DOM 元素引用   比如button,image,text
function removeButton()
4、被遗忘的定时器或者回调
5、子元素存在引起的内存泄露

```



##### 27、document.onload 和 onready有什么区别？

```css
1.onready或者$()比onload先执行

2.onready或者$()是页面解析完成之后执行，而onload是在页面所有元素加载完成后执行

3.onload只执行最后一个 而onready或者$()可以执行多个
```



##### 28、跨域是如何产生的，都有哪些解决跨域的方法？

```css
跨域出现的原因：浏览器的同源策略，同源策略主要用来防止CSRF攻击，同源策略会阻止一个域的JavaScript脚本和另外一个域的内容进行交互
出现跨域的场景：域名、端口号、协议有任何一个不一样的时候，就会出现跨域

解决方法：
1、通过jsonp跨域
2、postMessage跨域
3、跨域资源共享（CORS）
4、nginx代理跨域
5、nodejs中间件代理跨域
6、WebSocket协议跨域
```



##### 29、原生ajax如何实现的？http状态码：200、302、304、400、403、404、500、503分别是什么意思呀？

```css
200 OK //客户端请求成功 
400 Bad Request //客户端请求有语法错误，不能被服务器所理解 
403 Forbidden //服务器收到请求，但是拒绝提供服务 
404 Not Found //请求资源不存在，输入了错误的 URL 
500 Internal Server Error //服务器发生不可预期的错误 
503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```



##### 30、cookie、localStorage、sessionStorage有什么区别？

```css
cookie可以设置日期，日期到了后自动删除。  
localStorage 本地储存。不手动删除一直保存
sessionStorage 会话存储空间   网页关闭后自动删除
```



##### 31、如何实现防抖和节流？

```css
防抖：
用户多次触发事件，在用户一直触发事件中，事件不会执行，只有在用户停止触发事件一段时间之后再执行这个事件一次。

（原理）用户每一次触发事件都会延迟执行，在设置延迟定时器执之前都会把上一次延迟定时器清除，最终只有用户连续触发这个事件的间隔时间超出我们设置的参数ms毫秒之后,该事件才会触发一次

节流：
用户多次触发事件，在用户一直触发事件过程中事件会每间隔一段时间执行一次，会执行多次。

（原理）用户每一次触发事件都会设置一个延迟定时器，但是如果已经设置了延迟定时器就会等上一次延迟定时器执行之后才会开启下一个定时器，这样用户一直触发事件，事件会每间隔一段时间执行一次

```



##### 32、常见的字符串方法有哪些？

```css
1、字符串的比较 equals（）方法而不是使用==关系运算符，因为==比较的是字符串的内存地址；参数为字符串数组或者字符串都可以，返回值类型为Boolean值。

2、字符串的搜索 indexOf（）

3、截取子字符串 substring （）方法方法从字符串中截取需要的区间字符串，参数为整数，返回值为字符串。

4、去除首尾空白字符：使用trim方法可以移除字符串首尾的空白字符，参数为字符串，返回值类型也为字符串，并且还有isEmpty ()判断字符串是否为空字符串，与参数，返回值为Boolean值。

5、替换字符串：使用replace（）方法，参数为字符或者字符串，返回值为字符串。

6、分割字符串：使用split ()方法，参数为字符串，返回值为字符串数组。

7、拼接字符串：使用静态方法join（）方法，可以把指定的字符串连接成字符串数组，参数为字符串数组，返回值为字符串。

8、格式化字符串：使用format （）静态方法，可以传入其他占位符，然后生成新的字符串。返回值为字符串。

9、类型转换：可以把任意基本类型或者引用类型转换成字符串，使用的是静态方法value（）并且这是一个重载方法。参数可以为整数，小数，字符，字符串，或者Boolean值，返回值为Boolean值，int,double,字符串，

10、转换为char[]字符数组：String 和char[]类型可以相互转换。参数为字符串或者字符，返回值为字符或者字符串。

11、字符编码：ASCII码，GB2312，Unicode，或者UFT-8。英文的占用一个字节，中文的占用两个字节。

12、延伸阅读：早期版本的JDK     String 总是以char[]存储。
```



##### 33、常见的数组方法有哪些？splice和slice有什么区别？

```css
增  push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
	unshift()在数组开头添加任意多个值，然后返回新的数组长度
     splice()传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
	concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组
删 
	pop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项
	shift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项
	slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组
改
	splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响

查
	indexOf()返回要查找的元素在数组中的位置，如果没找到则返回 -1
	includes()返回要查找的元素在数组中的位置，找到返回true，否则false
	find()返回第一个匹配的元素


排序方法 sort()方法接受一个比较函数，用于判断哪个值应该排在前面
		join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串
迭代方法 / 批处理方法  
	some()对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true
	every()对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true
	forEach()对数组每一项都运行传入的函数，没有返回值
	filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回
	map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组

splice截取一段数组不会影响原数组  ，slice截取一段数组 影响原数组
```



##### 34、箭头函数和普通函数有哪些区别？

```css
1、箭头函数没有自己的this指向，它的this指向来源于它的上级，并且继承而来的this指向是无法改变的。
2、箭头函数由于没有自己的this，所以不能作为构造函数。   没有返回值
3、箭头函数中没有arguments（形参数组）

```



##### 35、模块化有哪些方式？

```css
AMD  依赖前置：提前引入，文件开头吧需要的模块一次性全部引入，后面直接使用，前期消耗比较大，后期执行效率很高代表作是require.js
CMD 按需加载：在代码执行过程当中需要一模块了才去加载，代表作是sea.js  现在不怎么使用了
ES6 Module  各大主流浏览器都支持  另外 服务器端Node.js 准训common.js规范 module.exports导出模块 require引入模块。

require.js
```



##### 36、["1", "2", "3"].map(parseInt) 答案是多少？

```css
1、NaN  NaN
```



##### 37、如何优化网页加载速度？

```css
1.减少 css，js 文件数量及大小(减少重复性代码，代码重复利用)，压缩 CSS 和 JS 代码 
2.图片的大小 
3.把 css 样式表放置顶部，把 js 放置页面底部 
4.减少 http 请求数 
5.使用外部 JS 和 CSS
合并http请求、精灵图（雪碧图）、字体（矢量图）、减少CDN
```



##### 38、如何实现对象的合并？数组的合并？

```css
对象的合并
方式一：扩展运算符 ...
扩展运算符合并对象当键名（属性名）相同时后面替换前面的
方式二：Object.assign(目标对象，来源对象) 合并对象
来源对象往目标对象合并，返回目标对象
如果目标对象、来源对象第一级属性名相同（键名）时，来源对象中的属性会替换目标对象中的属性，可以理解成后面替换前面属性中相同的键
方式三：for...in
简单数据类型合并  引用数据类型合并
数组的合并
concat，合并两个或多个数组 (会造成内存浪费，不能处理嵌套数组)
(...)展开运算符
```



##### 39、map和forEach有什么区别？

```css
1. 两者都可以用来遍历数组，forEach无返回值，map会映射并返回一个新的数组。
2. forEach会允许修改原数组的值，而map不能修改原数组的值。
```



##### 40、for...in 和 for...of 有什么区别？

```css
for...in只能获得对象的属性名，对数组来说是下标。并且手动添加的属性也能遍历到。
for...of可以用于遍历字符串也可以遍历数组 只能取得键值（数组），遍历对象会报错。
```







**Vue面试题**

**01、虚拟dom是什么？**

````vue
1、虚拟 DOM 就是用来模拟 DOM 的一个对象，这个对象拥有一些重要属性，并且更新 UI 主要就是通过 DIFF 方法对比旧的虚拟 DOM 树 和新的虚拟 DOM 树的区别完成的。

虚拟 DOM 的优点:
减少 DOM 操作
减少频率 (将多次操作合并为一次, 如添加 1000 个节点却一个接一个操作)
减少范围 (将多余的操作省掉, 如添加 1000 个节点其中只有 10 个是新增的)
跨平台
虚拟 DOM 不仅可以变成 DOM, 还可以变成小程序, ios 应用等, 本质是一个 js 对象
虚拟 DOM 的缺点
需要额外的创建函数, 如 createElement 或者 h, 但可以用 JSX 来简化成 XML 写法
````

02、双向绑定原理是什么？v-model组件实现的原理是什么？Object.defineProperty和Proxy有什么区别？

````vue
通过Object.defineProperty方法来给数据属性绑定setter和getter方法，进行数据赋值和获取值的一个劫持；vue核心库通过观察和消息发布来实现数据更新提示去更新内容、数据。
分别利用了v-bind用来绑定value的值，用v-on去绑定input标准事件，这是事件用来监听当输入域内容发生变化的时候来执行一些事情。
“Object.defineProperty无法一次性监听所有属性,要通过Object.keys进行循环遍历,Proxy不需要,直接可以监听所有属性。”
````

03、v-if 和 v-show 有什么区别？

````vue
(1)、v-if和v-show用于视图层进行条件判断视图展示

(2)、v-if的原理是根据判断条件来动态的进行增删DOM元素，v-show是根据判断条件来动态的进行显示和隐藏元素，频繁的进行增删DOM操作会影响页面加载速度和性能，由此我们可以得出结论：

当您的项目程序不是很大的时候，v-if和v-show都可以用来进行判断展示和隐藏（这种场景使用v-if只是影响不大，并不是没有影响）；

当您的项目程序比较大的时候，不推荐使用v-if来进行判断展示和隐藏，推荐使用v-show；

 (3)、只有v-if能和v-else连用进行分支判断，v-show是不能和v-else连用的，如果出现多种条件场景的情况下，可以使用v-if来进行判断
````

04、data为什么不是对象而是一个函数？

````vue
“因为在组件复用的时候会重新生成一个对象,而data是一个对象的话(因为对象是引用数据类型),data数据会被复用;而当data是一个函数的时候每次调用的时候就会返回一个新的data对象。”
````

05、watch和computed属性有什么区别？

````vue
1、功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。
2、是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。
3、是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。
4、computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）
5、使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.
````

06、v-for中key的作用？diff算法？

````vue
1.在写 v-for 的时候,都需要给元素加上一个 key 属性
2.key 的主要作用就是用来提高渲染性能的!
3.key 属性可以避免数据混乱的情况出现(如果元素中包含了有临时数据的元素,如果不用 key 就会产生数据混乱)

“diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较,并替换为新的节点,具体过程就是调用Patch方法,比较新旧节点,一边比较一边给真实DOM打补丁进行替换”
````

07、extends和mixins有什么区别？

````vue
1.mixins接收对象数组(可理解为多继承),extends接收的是对象或函数(可理解为单继承)
2.优先级>extends>mixins,继承钩子函数的时候,是不进行覆盖的,extends的钩子函数先触发,而后再是mixins的钩子函数触发,最后就是组件自身的钩子函数触发。
3.mixins类似于面向切面的编程(AOP),extends类似于面向对象的编程
````

08、对vue中插槽的理解？

````vue
插槽就是子组件中的提供给父组件使用的一个占位符，用<slot></slot> 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的<slot></slot>标签。

插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制简单来说就是组件外部维护参数及结构,内部安排位置

````

09、$nextTick的理解？

````vue
“nextTick(),是将回调函数延迟在下一次dom更新数据后调用,简单的理解是:当数据更新了,在dom中渲染后,自动执行该函数”
````

10、父子组件传值都有哪些方法？

````vue
父传子：通过父组件绑定自定义属性（或通过 v-bind 绑定动态属性），子组件使用 props 选项时显式的声明 props，以便它可以从父组件接收到期望的数据。
子传父：通过父组件绑定自定义事件，子组件通过 this.emit('自定义事件',value) 传值。
非父子：可以使用一个空的 Vue 实例绑定在 Vue 实例的原型上作为一个事件总线中心 (vue.prototype.eventBus = new Vue())，用 emit 触发事件，on 监听事件。
````

11、生命周期的理解？常用vue生命周期有哪些？created和mounted有什么区别？

````vue
8个，创建，挂载，更新，销毁 
created、mounted和beforeDestoryed 
created 数据和虚拟dom都完成创建，并且完成关联关系，不能获取虚拟dom，但是可以使用异步获取虚拟dom，如果非异步赋值，一定不会二次渲染
mounted 完成虚拟dom挂载，并不能保证样式渲染完成，如果赋值，一定会二次渲染
````

12、update生命周期出发是否有条件？

````vue
只有data里的变量改变并且要在页面重新渲染完成之后,才会进updated生命周期，只改变data里的值但是没有再页面上渲染该值的话并不会触发updated方法。
````

13、事件总线如何实现的？

````vue
全局事件总线就是为了实现各个组件的自由通信，传递数据

原理是假设有组件A和组件B，A和B之间关系可以是兄弟，父子，爷孙任意关系。然后A和B之间有一个中间商C，然后A可以在自身给C设置一个自定义事件，以及回调函数，然后假如B要给A传数据，就可以通过这个自定义事件去启动它，再后面传入数据作为参数。因此事件触发后运行回调函数，因为回调函数在A自身上，所所以A就得到了数据。
````

14、如何实现样式作用域？

````
vue中要给样式添加作用域,只需要给style标签添加scoped属性即可.
````

15、vue-router有哪几种路由模式？实现的原理是什么？

````
“vue-router有3种路由模式:hash,history,adstract.默认是hash
hash原理：在 url 中的 # 之后对应的是 hash 值, 其原理是通过hashChange() 事件监听hash值的变化, 根据路由表对应的hash值来判断加载对应的路由加载对应的组件
history原理：history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求(将url替换并且不刷新页面)
````

16、如何实现路由组件懒加载？

````
1、vue异步组件技术 ==== 异步加载
2、组件懒加载方案二 路由懒加载(使用import)
3、 组件懒加载方案三: webpack提供的require.ensure() 
````

17、路由导航卫士(钩子函数)有哪些？常用的钩子函数是哪些？

````
全局前置守卫 beforeEach
全局解析守卫 beforeResolve 
全局后置钩子 afterEach 

创建前/后： 在beforeCreated阶段，vue实例的挂载元素el还没有。在created阶段,vue实例的数据对象data有了,el还没有.

载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，

data.message还未替换。在mounted阶段，vue实例挂载完，data.message成功渲染。
更新前/后：当data变化时，会触发beforeUpdate和updated方法。

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
````

18、路由传参有哪些方式？

````
1.params 传参（显示参数）又可分为 声明式 和 编程式 两种方式
声明式router-link：该方式是通过router-link组件的to属性实现，子路由需要提前配置好参数
编程式 this.$router.push：同样需要子路由提前配置好参数。
2、params传参（不显示参数）也可分为声明式和编程式两种方式，与显示参数不同的是，这里是通过路由的别名 name 进行传值的
3、.query 传参（显示参数）也可分为声明式和编程式 两种方式
声明式router-link：该方式是通过 router-link 组件的 to 属性实现，不过使用该方式传值的时候，需要子路由提前配置好路由别名
编程式 this.$router.push：使用该方式传值的时候，同样需要子路由提前配置好路由别名（name 属性）

````

19、keep-alive组件的理解？它的生命周期有哪些？

````
1、keep-alive是Vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁。
2、生命周期函数：在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子activated 与 deactivated。
activated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。
deactivated钩子：组件被停用（离开路由）时调用。
````

20、vuex是什么？为什么要使用vuex？

````
1、vuex是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
2、使用 vue/react 等框架，需要关注点基本就是数据，因为框架解决了数据和页面更新的实现
所以组件和数据之间的对应关系，随着项目的复杂，变得混乱。所以需要统一管理数据，把数据的存取集中到一个地方，所有的组件都从这个地方取数据，更新数据也集中到同一个地方。
````

21、vuex有哪些常用属性？

````
vuex的属性有：1、state，用来存储变量；2、mutations，提交更新数据的方法；3、actions，用来解决异步流程来改变state数据；4、getters，对state里面的变量进行过滤的；5、modules。
````

22、vuex中为什么不能在mutations中进行异步赋值？

````
Mutation必须是同步函数
vuex和redux都是一种状态管理机制。然后他们会有自己的state（状态）和修改state的方法，修改state的方法涉及到同步和异步，vuex的处理方式是同步在mutation里面，异步在actions里面，然后redux的同步就是reducer,异步更多的是用户自己去通过中间件的方式去实现
````

23、如何实现数据持久化(刷新页面不丢失)？

````
将vuex中的数据进行本地存储，防止页面刷新丢失vuex中的数据。
````

24、axios有什么优点？

````
1. 支持Promise API

2. 拦截请求和响应

3. 转换请求数据和响应数据

4. 取消请求

5.自动转换json数据
````

25、ref是什么？如何实现实例传参或方法调用？

````
ref是组件的特殊属性，组件被渲染后，指向组件的一个引用。可以通过组件的ref属性，来获取真实的组件。 因为，组件并不是真正的DOM节点，而是存在于内存中的一种数据结构，称为虚拟的DOM，只有当它真正的插入文档之后，才变为真正的DOM节点

ref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期 mounted(){} 钩子中调用，或者在 this.$nextTick(()=>{}) 中调用。
````

26、修饰符

.stop 阻止事件冒泡

.prevent 阻止默认事件

.self 避免事件冒泡 (只有自身才能触发)

.once 只能触发一次

```vue
<template>
  <div class="hello">
    <!-- 阻止事件冒泡 -->
    <p @click="paerts()">
      父元素
      <span @click.stop="sons()">子元素</span>
    </p>
    <!-- 阻止默认事件 -->
    <a @click.prevent="sons()" href="baidu.com">链接</a>

    <!-- 避免事件冒泡 (只有自身才能触发)-->
    <p @click.self="paerts()">
      父元素
      <span @click="sons()">子元素</span>
    </p>

    <!-- 只能触发一次 -->
    <button @click.once="paerts()">一次</button>
  </div>
</template>

<script>
export default {
  data() {
    return {};
  },
  computed: {},
  methods: {
    paerts() {
      console.log("父元素方法");
    },
    sons() {
      console.log("子元素方法");
    }
  }
};
</script>
```

